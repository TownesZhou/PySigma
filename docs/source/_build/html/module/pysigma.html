

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pysigma package &mdash; PySigma 0.0.2 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> PySigma
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction/intro.html">Introduction and Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../introduction/getting-started.html">Getting Started</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../references/index.html">References</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../references/cognitive/index.html">Cognitive</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../references/cognitive/predicate.html">Predicate</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../references/graphical/index.html">Graphical</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../references/graphical/message.html">Message</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../references/utils/index.html">Utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Example Models</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySigma</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>pysigma package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/module/pysigma.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pysigma-package">
<h1>pysigma package<a class="headerlink" href="#pysigma-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pysigma.cognitive.html">pysigma.cognitive package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pysigma.cognitive.html#module-pysigma.cognitive">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pysigma.graphical.html">pysigma.graphical package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pysigma.graphical.html#module-pysigma.graphical">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pysigma.defs">
<span id="pysigma-defs-module"></span><h2>pysigma.defs module<a class="headerlink" href="#module-pysigma.defs" title="Permalink to this headline">¶</a></h2>
<p>Basic structures in the graphical architecture</p>
<dl class="py class">
<dt id="pysigma.defs.InferenceMethod">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.defs.</code><code class="sig-name descname">InferenceMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.InferenceMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt id="pysigma.defs.InferenceMethod.BP">
<code class="sig-name descname">BP</code><em class="property"> = 0</em><a class="headerlink" href="#pysigma.defs.InferenceMethod.BP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.InferenceMethod.EP">
<code class="sig-name descname">EP</code><em class="property"> = 4</em><a class="headerlink" href="#pysigma.defs.InferenceMethod.EP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.InferenceMethod.PARTICLE_BP">
<code class="sig-name descname">PARTICLE_BP</code><em class="property"> = 1</em><a class="headerlink" href="#pysigma.defs.InferenceMethod.PARTICLE_BP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.InferenceMethod.PARTICLE_EP">
<code class="sig-name descname">PARTICLE_EP</code><em class="property"> = 5</em><a class="headerlink" href="#pysigma.defs.InferenceMethod.PARTICLE_EP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.InferenceMethod.PARTICLE_VMP">
<code class="sig-name descname">PARTICLE_VMP</code><em class="property"> = 3</em><a class="headerlink" href="#pysigma.defs.InferenceMethod.PARTICLE_VMP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.InferenceMethod.VMP">
<code class="sig-name descname">VMP</code><em class="property"> = 2</em><a class="headerlink" href="#pysigma.defs.InferenceMethod.VMP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pysigma.defs.Message">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.defs.</code><code class="sig-name descname">Message</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg_type</span></em>, <em class="sig-param"><span class="n">batch_shape</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">param_shape</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_shape</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">event_shape</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">parameters</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">particles</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_densities</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Message structure to support general inference.</p>
<dl>
<dt>Two basic message types:</dt><dd><ul>
<li><dl class="simple">
<dt>Parameter: parameters to a batch of distributions that this message is encoding</dt><dd><ul class="simple">
<li><p>Contains a batched parameter tensor, of shape (batch_shape + param_shape)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>Particles: Lists of marginally drawn particles w.r.t. each single random variable. The combination of</dt><dd><p>particles approximates the batch of joint target distributions this message is encoding via importance
weighting. Comprise of the following components:
- Particle Value Tensors List:</p>
<blockquote>
<div><p>Each one corresponds to particles marginally drawn w.r.t. one random variable.
With shape [sample_size_j, event_size_j] for the jth random variable.</p>
</div></blockquote>
<ul>
<li><dl>
<dt>Weight Tensor:</dt><dd><dl class="simple">
<dt>A single, positively valued tensor that encodes the importance weighting of each joint combination</dt><dd><p>of particles w.r.t. each joint distribution in the batch. The values should sum up to 1 across
the tensor subspace spanned by all sample dimensions.</p>
</dd>
</dl>
<p>If all weights are uniform, can use an int of 1 as the abbreviation.
With shape (batch_shape + sample_shape) where batch_shape is the concatenation of of batch sizes,</p>
<blockquote>
<div><p>and sample_shape is the concatenation of all sample sizes.</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt>Log Sampling Density Tensors List:</dt><dd><dl class="simple">
<dt>Each one corresponds to the log sampling density of the corresponding particles in the Particle</dt><dd><p>Value Tensors List.</p>
</dd>
<dt>If a particle value tensor was drawn uniformly, its corresponding log sampling density can be</dt><dd><p>abbreviated by an int of 1.</p>
</dd>
</dl>
<p>With shape [sample_size_j] for the jth random variable.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>Message content shape (when they are torch tensors), assuming there are N relational variables and M random</dt><dd><p>variables:
- Parameter:                    [batch_size_0, …, batch_size_N, param_size]
- Particle Value Tensor:        each of shape [sample_size_j, event_size_j]
- Weight Tensor:                [batch_size_0, …, batch_size_N, sample_size_0, …, sample_size_M]
- Log Sampling Density Tensor:  each of shape [sample_size_j]</p>
</dd>
<dt>Message shape constraints:</dt><dd><ul class="simple">
<li><p>sample_shape must have AT LEAST length 1, the same length as event_shape.</p></li>
<li><p>batch_shape must have AT LEAST length 1.</p></li>
<li><p>event_shape must have AT LEAST length 1, the same length as sample_shape.</p></li>
<li><p>param_shape must have EXACTLY length 1.</p></li>
</ul>
</dd>
<dt>The semantics of a Message is determined not only by its type, but by its context as well. In other words,</dt><dd><p>which distribution or distribution class a Message represents, or whether a Parameter type message
represents a Natural parameter to an exponential distribution or a distribution-class specific parameter to
PyTorch’s distribution class interface, is of no concern to the Message structure itself.</p>
</dd>
<dt>Both types of messages are endowed with certain arithmetic structures:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>For Parameter messages,</dt><dd><ul>
<li><p>Addition operation is defined as addition on the parameter tensors.</p></li>
<li><p>Scalar multiplication is defined as scalar multiplication with the parameter tensors</p></li>
<li><p>0 is treated as the identity element.</p></li>
<li><p>Parameter message structure therefore constructs and defines the “parameter space”.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For Particles messages:</dt><dd><ul>
<li><dl class="simple">
<dt>The following two operations are defined as operations on the particle weights, and meaningful only</dt><dd><p>for Particle messages that share the same particle values and the same sampling log density of the
particles. In addition, results from these two operations are normalized so that the weight tensor
sum to 1 across the sample dimension.</p>
</dd>
</dl>
</li>
<li><p>“Addition” operation is defined as element-wise multiplication of particle weights tensors.</p></li>
<li><dl class="simple">
<dt>“Scalar multiplication” is defined as taking elements of the particle weights tensor to the power</dt><dd><p>of the scalar.</p>
</dd>
</dl>
</li>
<li><p>1 is treated as the identity element for the element-wise multiplication operation.</p></li>
<li><dl class="simple">
<dt>It turns out that the “addition” and “scalar multiplication” as defined above satisfy associativity</dt><dd><p>and distributivity. With the set of possible weights closed under both operations, a vector space
is therefore constructed and defined.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Accordingly, the ‘+’ and ‘*’ operator are overloaded according the to the specifications above.</p>
<dl class="py method">
<dt id="pysigma.defs.Message.batch_broaden">
<code class="sig-name descname">batch_broaden</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em>, <em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_broaden" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a new message that is a broadened version of the input tensor along the dimension specified by</dt><dd><p>‘dim’, with identity values filled in [dim_size + 1: length] along the dimension ‘dim’ of the original
message. In other words, this method is concatenating an identity message to the original message along
the dimension ‘dim’ so that the resulting dimension size is ‘length’.</p>
</dd>
<dt>For Parameter type message, the identity values are 0. For Particles type message, the identity values are 1</dt><dd><p>up to a normalization factor.</p>
</dd>
</dl>
<p>contiguous() will be called before return to make sure the resulting content tensors are contiguous</p>
<dl class="simple">
<dt>This method is the inverted version of batch_narrow(). There is no direct counterpart to this method in</dt><dd><p>PyTorch.</p>
</dd>
<dt>:param dim      an int. Specifying a dimension of the original message. Should be in range</dt><dd><p>[-len(batch_shape), len(batch_shape) - 1]</p>
</dd>
<dt>:param length   an int. Specifying the length of the message chunk to select. Should be greater than the</dt><dd><p>current size of dimension ‘dim’</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_diag_embed">
<code class="sig-name descname">batch_diag_embed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">diag_dim</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">target_dim1</span><span class="o">=</span><span class="default_value">- 2</span></em>, <em class="sig-param"><span class="n">target_dim2</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_diag_embed" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Creates a message whose diagonals of certain 2D planes (dimensions specified by ‘target_dim1’ and</dt><dd><p>‘target_dim2’) are filled by vectors of self (dimension specified by ‘diag_dim’). The last dimension of
self is chosen by default as the diagonal entries to be filled, and the last two dimensions of the new
message are chosen by default as the 2D planes where the diagonal entries will be filled in.</p>
</dd>
<dt>The 2D planes will be shaped as square matrices, with the size of each dimension matches the size of the</dt><dd><p>diag_dim in self.</p>
</dd>
</dl>
<p>The length of returned message’s batch shape will be the length of original message’s batch shape plus 1.</p>
<dl class="simple">
<dt>For slots not on the diagonal of the resulting message, they will be filled with identity values. For</dt><dd><p>Parameter type message, the identity value is 0 w.r.t. the parameter tensor, and for Particles type
message, the identity value is 1 w.r.t. the weights tensor up to a normalization factor.</p>
</dd>
</dl>
<p>contiguous() will be called before return to make sure the resulting content tensors are contiguous</p>
<p>This method is a mimic of torch.diag_embed(), with offset default to 0 plus an additional diag_dim argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diag_dim</strong> – an int. Specifying a dimension of the original message. Should be in range
[-len(batch_shape), len(batch_shape) - 1]</p></li>
<li><p><strong>target_dim1</strong> – an int. Specifying a dimension of the returned message. Should be in range
[-len(batch_shape) - 1, len(batch_shape)]</p></li>
<li><p><strong>target_dim2</strong> – Same as ‘target_dim1’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_diagonal">
<code class="sig-name descname">batch_diagonal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim1</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dim2</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a partial view of self with the its diagonal elements with respect to ‘dim1’ and ‘dim2’ appended as</dt><dd><p>a dimension at the end of the shape.</p>
</dd>
</dl>
<p>dim values within the range [-len(batch_shape), len(batch_shape) - 1] can be used.
Note that ‘dim1’ and ‘dim2’ are relative to the batch dimension. The appended dimension will be placed as</p>
<blockquote>
<div><p>the last batch dimension, but before any event or param dimension.</p>
</div></blockquote>
<p>contiguous() will be called before return to make sure the resulting content tensors are contiguous</p>
<p>This method is a mimic of torch.diagonal(), with offset default to 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dim1</strong> – an int. Should be in range [-len(batch_shape), len(batch_shape) - 1]</p>
</dd>
</dl>
<p>:param dim2.    Same as ‘dim1’</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_expand">
<code class="sig-name descname">batch_expand</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_batch_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new view of the self message with singleton batch dimensions expanded to a larger size.</p>
<p>Passing a -1 as the size for a dimension means not changing the size of that dimension.</p>
<dl class="simple">
<dt>Expanding a message would not allocate new memory for the tensor contents, but create a new view on the</dt><dd><p>existing tensor. Any dimension of size 1 can be expanded to an arbitrary value without allocating new
memory.</p>
</dd>
<dt>Note that more than one element of an expanded message may refer to a single memory location. As a result,</dt><dd><p>in-place operations may result in incorrect behavior. Clone first before needing to write in-place to
the message tensor contents.</p>
</dd>
</dl>
<p>This method is a mimic of torch.expand()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_batch_shape</strong> – Iterable of python ints, or torch.Size. The target expanded batch shape. Must
have the same length as self’s current batch shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_flatten">
<code class="sig-name descname">batch_flatten</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_flatten" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Flattens the set of batch dimensions specified by ‘dims’ and append the flattened dimension as the last</dt><dd><p>dimension. If ‘dims’ is None, will flatten all batch dimensions into a single dimension.</p>
</dd>
</dl>
<p>contiguous() will be called before return to make sure the resulting content tensors are contiguous</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dims</strong> – None or an Iterable of ints. Specifying the set of dimensions to be flattened. If given,
each value should be in range   [-len(batch_shape), len(batch_shape) - 1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_index_put">
<code class="sig-name descname">batch_index_put</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_index_put" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a new Message whose entries along the dimension ‘dim’ are slices from self message and are indexed</dt><dd><dl class="simple">
<dt>by ‘index’. Effectively, along the dimension ‘dim’:</dt><dd><p>result_msg[…, index[i], …] = val[i]</p>
</dd>
</dl>
</dd>
<dt>For slices in the new message not referenced by ‘index’, they will be filled with identity values. For</dt><dd><p>Parameter type message, the identity value is 0; for Particles type message, the identity value is 1,
up to a normalization factor.</p>
</dd>
<dt>This method is the inverted version of batch_index_select(). There is no direct counterpart to this method</dt><dd><p>in PyTorch.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> – an int. Specifying a dimension of the message. Should be in range
[-len(batch_shape), len(batch_shape) - 1]</p></li>
<li><p><strong>index</strong> – a LongTensor. Specifying the indices along the specified dimension of the returned message.
Entries must be non-negative.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_index_select">
<code class="sig-name descname">batch_index_select</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_index_select" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a new Message which indexes the input message along batch dimension dim using the entries in index</dt><dd><p>which is a LongTensor.</p>
</dd>
<dt>A ‘dim’ value within the range [-len(batch_shape), len(batch_shape) - 1] can be used. Note that ‘dim’</dt><dd><p>is relative to the batch dimension only.</p>
</dd>
</dl>
<p>This method is a mimic of batch_index_select()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> – an int. The dimension along which entries will be selected according to ‘index’</p></li>
<li><p><strong>index</strong> – torch.LongTensor. The index of entries along ‘dim’ to be selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_narrow">
<code class="sig-name descname">batch_narrow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em>, <em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_narrow" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a new message that is a narrowed version of input tensor along the dimension specified by ‘dim’.</dt><dd><p>Effectively, this method is selecting the chunk spanning [:length] along the dimension ‘dim’ of the
original message. The returned message and input message share the same underlying storage.</p>
</dd>
</dl>
<p>contiguous() will be called before return to make sure the resulting content tensors are contiguous</p>
<p>This method is a mimic of torch.narrow(), with start default to 0.</p>
<dl class="simple">
<dt>:param dim      an int. Specifying a dimension of the original message. Should be in range</dt><dd><p>[-len(batch_shape), len(batch_shape) - 1]</p>
</dd>
<dt>:param length   an int. Specifying the length of the message chunk to select. Should be in range</dt><dd><p>[0, dim_size - 1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_permute">
<code class="sig-name descname">batch_permute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target_dims</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_permute" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a permuted message whose tensor attributes are permuted from the original ones w.r.t. ‘target_dims’</dt><dd><p>in the batch dimensions.</p>
</dd>
<dt>Note that target_dims is relative to the batch dimension. Its values should be within the range</dt><dd><p>[-len(batch_shape), len(batch_shape) - 1]</p>
</dd>
</dl>
<p>contiguous() will be called before return to make sure the resulting content tensors are contiguous</p>
<p>This method is a mimic of torch.Tensor.permute()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>target_dims</strong> – list of ints. The desired ordering batch dimensions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_reshape">
<code class="sig-name descname">batch_reshape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_batch_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a message with the same data as self, but with the specified ‘new_batch_shape’.</p>
<p>This method is a mimic of torch.reshape()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_batch_shape</strong> – Iterable of python ints, or torch.Size. The target batch shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_summarize">
<code class="sig-name descname">batch_summarize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_summarize" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Implements the default Sum-Product summarization semantics. Summarizes over the batch dimension specified by</dt><dd><p>‘dim’. Returns a message with one less dimension.</p>
</dd>
<dt>For Parameter message, the summarization is realized by taking the mean value of the batched parameters</dt><dd><p>across dimension ‘dim’. For particles message, this is realized by taking joint addition defined for
particle weights, a.k.a. factor product.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dim</strong> – an int. Specifying a dimension of the original message. Should be in range
[-len(batch_shape), len(batch_shape) - 1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.batch_unsqueeze">
<code class="sig-name descname">batch_unsqueeze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.batch_unsqueeze" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a new message with a dimension of size one inserted at the specified batch dimension, similar to</dt><dd><p>torch.unsqueeze().</p>
</dd>
<dt>A ‘dim’ value within the range [-len(batch_shape) - 1, len(batch_shape) + 1] can be used. Note that ‘dim’</dt><dd><p>is relative to the batch dimension only.</p>
</dd>
</dl>
<p>This method is a mimic of torch.unsqueeze()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dim</strong> – an int. The place where the new dimension of size one will be inserted at.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.clone" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return a cloned message from self. Guarantees that every content is deep-copied. Tensors will be cloned and</dt><dd><p>dictionaries will be deep-copied.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.event_transform">
<code class="sig-name descname">event_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trans</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.event_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation on the event values. Return the transformed message.</p>
<p>Message contents will be cloned.</p>
<dl class="simple">
<dt>For particles:</dt><dd><ul class="simple">
<li><p>Apply the transformation directly on the particle values</p></li>
<li><dl class="simple">
<dt>Log sampling densities will be adjusted by adding the log abs determinant of the Jacobian of the</dt><dd><dl class="simple">
<dt>transformation:</dt><dd><p>log P(Y) = log P(X) + log <a href="#id1"><span class="problematic" id="id2">|det (dX / dY)|</span></a></p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><p>Weights are kept the same, but the tensor will be cloned.</p></li>
</ul>
</dd>
<dt>For parameters:</dt><dd><ul class="simple">
<li><p>Raise an alert if ‘dist_class’ attribute is missing in self.attr</p></li>
<li><p>Query DistributionServer to obtained the transformed parameter.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>trans</strong> – torch.distributions.transforms.Transform. The transformation functor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.event_translate_2pred">
<em class="property">static </em><code class="sig-name descname">event_translate_2pred</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">translator</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.event_translate_2pred" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate msg’s particles from PyTorch format to Cognitive format, using the given translator.</p>
<dl class="simple">
<dt>If there are multiple r.v., will return a tuple of translated messages, elements corresponding to each r.v.</dt><dd><p>specified in the translator. In this case, the particle weights and log sampling densities will be
copied for each split event particles to form new messages.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msg</strong> – a Message instance. The message to be translated.</p></li>
<li><p><strong>translator</strong> – a KnowledgeTranslator instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.event_translate_2torch">
<em class="property">static </em><code class="sig-name descname">event_translate_2torch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msgs</span></em>, <em class="sig-param"><span class="n">translator</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.event_translate_2torch" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Translate provided iterable of messages’ particles from Cognitive format to form a message with particles in</dt><dd><p>PyTorch format, using the given translator.</p>
</dd>
<dt>The message order in the given iterable should conform to the random variable order specified in the</dt><dd><p>translator.</p>
</dd>
</dl>
<p>Return a single message.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msgs</strong> – an iterable of Message instances. Order should be compatible with the order of random
variables specified in the given translator.</p></li>
<li><p><strong>translator</strong> – a KnowledgeTranslator instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.reduce_type">
<code class="sig-name descname">reduce_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg_type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.reduce_type" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return a ‘msg_type’ type reduced self message, where irrelevant components w.r.t. ‘msg_type’ is removed, and</dt><dd><p>the relevant components are retained and cloned.</p>
</dd>
</dl>
<p>Return self and do nothing if msg_type is self type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg_type</strong> – MessageType.Parameter or MessageType.Particles.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.same_size_as">
<code class="sig-name descname">same_size_as</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.same_size_as" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self has the same shape as the other message. Return True if so.</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.defs.Message.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Message.size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a tuple of the message’s shapes:</dt><dd><p>(sample_shape, batch_shape, param_shape, event_shape)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pysigma.defs.MessageType">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.defs.</code><code class="sig-name descname">MessageType</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.MessageType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Flag</span></code></p>
<p>Enum class to represent message types</p>
<dl class="simple">
<dt>The True-valued boolean relationship between types, using the ‘in’ operator:</dt><dd><ul class="simple">
<li><p>Undefined in Undefined == Undefined in Parameter == Undefined in Particles == Undefined in Both == True</p></li>
<li><p>Parameter in Parameter == Undefined in Both == True</p></li>
<li><p>Particles in Particles == Undefined in Both == True</p></li>
</ul>
</dd>
</dl>
<p>All other relations are False.</p>
<dl class="py attribute">
<dt id="pysigma.defs.MessageType.Both">
<code class="sig-name descname">Both</code><em class="property"> = 3</em><a class="headerlink" href="#pysigma.defs.MessageType.Both" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.MessageType.Parameter">
<code class="sig-name descname">Parameter</code><em class="property"> = 1</em><a class="headerlink" href="#pysigma.defs.MessageType.Parameter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.MessageType.Particles">
<code class="sig-name descname">Particles</code><em class="property"> = 2</em><a class="headerlink" href="#pysigma.defs.MessageType.Particles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.MessageType.Undefined">
<code class="sig-name descname">Undefined</code><em class="property"> = 0</em><a class="headerlink" href="#pysigma.defs.MessageType.Undefined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pysigma.defs.Variable">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.defs.</code><code class="sig-name descname">Variable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">metatype</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">value_constraints</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.Variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="simple">
<dt>Variable as in variable nodes in the graphical architecture. Store information about this variable such as</dt><dd><p>its meta-type and dimension size</p>
</dd>
<dt>The equality testing is used for matching variables in Alpha-Beta graphs. Two variables are equal if and only</dt><dd><p>if ALL of the fields are equal.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="pysigma.defs.VariableMetatype">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.defs.</code><code class="sig-name descname">VariableMetatype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.defs.VariableMetatype" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>An enumeration.</p>
<dl class="py attribute">
<dt id="pysigma.defs.VariableMetatype.Indexing">
<code class="sig-name descname">Indexing</code><em class="property"> = 0</em><a class="headerlink" href="#pysigma.defs.VariableMetatype.Indexing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.VariableMetatype.Parameter">
<code class="sig-name descname">Parameter</code><em class="property"> = 3</em><a class="headerlink" href="#pysigma.defs.VariableMetatype.Parameter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.VariableMetatype.Random">
<code class="sig-name descname">Random</code><em class="property"> = 2</em><a class="headerlink" href="#pysigma.defs.VariableMetatype.Random" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.defs.VariableMetatype.Relational">
<code class="sig-name descname">Relational</code><em class="property"> = 1</em><a class="headerlink" href="#pysigma.defs.VariableMetatype.Relational" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysigma.sigmaboard">
<span id="pysigma-sigmaboard-module"></span><h2>pysigma.sigmaboard module<a class="headerlink" href="#module-pysigma.sigmaboard" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Sigmaboard, resembling the concept of Tensorboard from Tensorflow, a web-based interactive visualization tool for</dt><dd><p>Sigma graphical backend.</p>
</dd>
</dl>
<dl class="py class">
<dt id="pysigma.sigmaboard.SigmaBoard">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.sigmaboard.</code><code class="sig-name descname">SigmaBoard</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.sigmaboard.SigmaBoard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt id="pysigma.sigmaboard.SigmaBoard.external_scripts">
<code class="sig-name descname">external_scripts</code><em class="property"> = ['https://code.jquery.com/jquery-1.12.4.js', 'https://code.jquery.com/ui/1.12.1/jquery-ui.js']</em><a class="headerlink" href="#pysigma.sigmaboard.SigmaBoard.external_scripts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.sigmaboard.SigmaBoard.external_stylesheets">
<code class="sig-name descname">external_stylesheets</code><em class="property"> = ['https://codepen.io/chriddyp/pen/bWLwgP.css', 'https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css']</em><a class="headerlink" href="#pysigma.sigmaboard.SigmaBoard.external_stylesheets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.sigmaboard.SigmaBoard.render">
<code class="sig-name descname">render</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.sigmaboard.SigmaBoard.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the Dash server locally</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pysigma.sigmaboard.cosine_similarity">
<code class="sig-prename descclassname">pysigma.sigmaboard.</code><code class="sig-name descname">cosine_similarity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span> &#x2192; Tensor<a class="headerlink" href="#pysigma.sigmaboard.cosine_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns cosine similarity between x1 and x2, computed along dim.</p>
<div class="math notranslate nohighlight">
\[\text{similarity} = \dfrac{x_1 \cdot x_2}{\max(\Vert x_1 \Vert _2 \cdot \Vert x_2 \Vert _2, \epsilon)}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> (<em>Tensor</em>) – First input.</p></li>
<li><p><strong>x2</strong> (<em>Tensor</em>) – Second input (of size matching x1).</p></li>
<li><p><strong>dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Dimension of vectors. Default: 1</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em>) – Small value to avoid division by zero.
Default: 1e-8</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Shape:</dt><dd><ul class="simple">
<li><p>Input: <span class="math notranslate nohighlight">\((\ast_1, D, \ast_2)\)</span> where D is at position <cite>dim</cite>.</p></li>
<li><p>Output: <span class="math notranslate nohighlight">\((\ast_1, \ast_2)\)</span> where 1 is at position <cite>dim</cite>.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">input1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">input2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cosine_similarity</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pysigma.structures">
<span id="pysigma-structures-module"></span><h2>pysigma.structures module<a class="headerlink" href="#module-pysigma.structures" title="Permalink to this headline">¶</a></h2>
<p>Common structures and componenets serving the Sigma cognitive language</p>
<p>Author of this file: Jincheng Zhou, University of Southern California</p>
<dl class="py class">
<dt id="pysigma.structures.Conditional">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.structures.</code><code class="sig-name descname">Conditional</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conditional_name</span></em>, <em class="sig-param"><span class="n">conditions</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">condacts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">actions</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">function_var_names</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.Conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="pysigma.structures.FactorFunction">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.structures.</code><code class="sig-name descname">FactorFunction</code><a class="headerlink" href="#pysigma.structures.FactorFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class type for factor node function</p>
<dl>
<dt>A FactorFunction instance can be thought of as a function object that takes in a group of batched tensors, each</dt><dd><p>corresponding to a batched value assignments to a random variable, and produces a single batched tensor that
represents the joint probability density, i.e.,</p>
<blockquote>
<div><p>val = Prob(X_1, X_2, …, X_n)</p>
</div></blockquote>
<p>where val, X_1, X_2, …, X_n are all batched over the first dimension.</p>
</dd>
<dt>The first dimension of all tensors indexes the group of value assignments to the random variables. Therefore, it</dt><dd><p>should be ignored by the factor function procedure and simply treated as the “batched” dimension.</p>
</dd>
<dt>Defines different types of factor functions:</dt><dd><ol class="loweralpha">
<li><dl>
<dt>Tabular factor function</dt><dd><dl class="simple">
<dt>Returns a full-dimensional tensor at once representing the entire factor function table, each dimension</dt><dd><p>corresponds to a random variable’s support. Suitable when all random variables X_1, …, X_n have
finite discrete domains and the size is manageable.</p>
</dd>
<dt>For this type of factor function, no inputs regarding the R.V. values are necessary, because the</dt><dd><p>returned factor table should cover all combinations of inputs.</p>
</dd>
</dl>
<p>This is the same as the legacy Lisp Sigma’s factor node function</p>
</dd>
</dl>
</li>
<li><dl>
<dt>General form generative joint-probability density function</dt><dd><dl>
<dt>Given a batched group of RV value assignments as inputs, returns a batched tensor array representing the</dt><dd><dl class="simple">
<dt>probability density. To enforce the probabilistic semantics, i.e.,</dt><dd><p>val = Prob(X_1, X_2, …, X_n)</p>
</dd>
</dl>
<p>The entries in the returned tensor should be within the range [0, 1].</p>
</dd>
</dl>
<p>Compatible with all particle-based inference methods</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Exponential form joint-probability density function</dt><dd><dl class="simple">
<dt>Explicitly defines an exponential distribution. Encodes an exponential distribution class as the</dt><dd><p>factor node conditional distribution. Returns the PARAMETERS to the distribution.</p>
</dd>
<dt>Must declare this type if want architecture to recognize conjugate-exponential model structure and</dt><dd><p>carries out closed-form message updates.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl>
<dt>Deterministic factor function</dt><dd><dl class="simple">
<dt>Returns one or multiple batched VALUE tensors corresponding to one or multiple R.V.s given a batched</dt><dd><dl class="simple">
<dt>value assignments to other variables. Enforce the semantics of</dt><dd><p>Y_1, Y_2, …, Y_m = Func(X_1, X_2, …, X_n)</p>
</dd>
</dl>
</dd>
<dt>Conceptually identical to (b) type factor function with a delta distribution, but due to concerns of</dt><dd><p>sample efficiency, this type should be used in practice if the factor function is deterministic.</p>
</dd>
</dl>
<p>Note that once defined, the directionality of the corresponding Conditional is also assumed and fixed.
In other words, X_1, …, X_n should only appear in condition patterns, and Y_1, …, Y_m only in action
patterns.</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="pysigma.structures.Predicate">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.structures.</code><code class="sig-name descname">Predicate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicate_name</span></em>, <em class="sig-param"><span class="n">relational_args</span></em>, <em class="sig-param"><span class="n">random_args</span></em>, <em class="sig-param"><span class="n">inference_mode</span></em>, <em class="sig-param"><span class="n">num_particles</span><span class="o">=</span><span class="default_value">128</span></em>, <em class="sig-param"><span class="n">distribution_class</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">memorial</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">perceptual</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.Predicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="pysigma.structures.Summarization">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.structures.</code><code class="sig-name descname">Summarization</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sum_func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.Summarization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl>
<dt>Class type for declaring procedures for summarization over space of distribution instances spanned by relational</dt><dd><p>variable dimensions.</p>
</dd>
<dt>User should provide a functor that can be called to perform the summarization procedure. Generally, the functor</dt><dd><p>should be expecting to receive and process both Parameter representation of message and Particles
representation of message, with a flag indicating which type current input is.</p>
</dd>
<dt>The functor Input/Output specification:</dt><dd><dl class="field-list">
<dt class="field-odd">param message_type</dt>
<dd class="field-odd"><p>“parameter”, “particles”, or “both”</p>
</dd>
<dt class="field-even">param message</dt>
<dd class="field-even"><p>a dict. with the following schema:
- For “parameter” message type, expect the following:</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>“parameter”: a torch.Tensor, with dimensions [batch_dim, sum_dim, param_dim]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<ul>
<li><dl>
<dt>For “particles” message type, expect the following:</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>“particles”: a dict mapping Random Variable name to torch.Tensor, with the</dt><dd><blockquote>
<div><p>following schema:</p>
</div></blockquote>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>a str, the random variable name: a torch.Tensor with dimensions</dt><dd><p>[sample_dim, rv_dim]</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>“weights”: a torch.Tensor, with dimensions [batch_dim, sum_dim, sample_dim],
“log_density”: a torch.Tensor, with dimension [sample_dim]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</li>
<li><p>For “both” message type, expect a dictionary containing all of the contents above.</p></li>
</ul>
</dd>
<dt class="field-odd">return                 a torch.Tensor. Depending on the type of message</dt>
<dd class="field-odd"><ul class="simple">
<li><dl class="simple">
<dt>For “parameter” message type, expect the following:</dt><dd><dl class="simple">
<dt>“parameter”: the processed parameter torch.Tensor, with dimension</dt><dd><p>[batch_dim, param_dim]</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For “particles” message type, expect the following:</dt><dd><dl class="simple">
<dt>“weights”: the processed weights torch.Tensor, with dimensions</dt><dd><p>[batch_dim, sample_dim],</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For “both” message type, expect a TUPLE of torch.Tensor containing both of the</dt><dd><p>contents above. The first element is expected to be the “parameter” and the
second one is expected to be the “weights”</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Explanation for the shapes:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>‘batch_dim’: the batch dimension, as in machine learning. This dimension indexes batch of data instances,</dt><dd><p>and should not be tampered with.</p>
</dd>
</dl>
</li>
<li><p>‘sum_dim’:   the dimension to be summarized over. This dimension should be reduced during the processing.</p></li>
<li><p>‘param_dim’: the dimension of the parameter.</p></li>
<li><dl class="simple">
<dt>‘sample_dim’:     the dimension that indexes particles in a particle list. Size of this dimension</dt><dd><p>corresponds to the number of particles drawn.</p>
</dd>
</dl>
</li>
<li><p>‘rv_dim’:      the dimension of the corresponding random variable. Same the same as the size of the RV.</p></li>
</ul>
</dd>
<dt>All input tensors will first be cloned before being fed to the functor, because we don’t expect “particles”</dt><dd><p>and “log_density” tensors to be changed during summarization.</p>
</dd>
</dl>
<dl class="py method">
<dt id="pysigma.structures.Summarization.process">
<code class="sig-name descname">process</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">ran_var_list</span></em>, <em class="sig-param"><span class="n">translator</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.Summarization.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Should be called by nodes to perform the summarization. Shape checks will be carried out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msg</strong> – A flattened Message instance. The last batch dimension is the one assumed to be summarized
over.</p></li>
<li><p><strong>ran_var_list</strong> – List of random variables.</p></li>
<li><p><strong>translator</strong> – A KnowledgeTranslator instance. To translate the particles tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new message</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pysigma.structures.Type">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.structures.</code><code class="sig-name descname">Type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">type_name</span></em>, <em class="sig-param"><span class="n">symbolic</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">symbol_list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">value_constraint</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.Type" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="pysigma.structures.VariableMap">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.structures.</code><code class="sig-name descname">VariableMap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapping_func</span></em>, <em class="sig-param"><span class="n">domain</span></em>, <em class="sig-param"><span class="n">codomain</span></em>, <em class="sig-param"><span class="n">dynamic</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.VariableMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class type for declaring mappings on relational variables in pattern elements</p>
<dl class="simple">
<dt>Since relational variables can be viewed as non-negative finite integer-valued variables, a VariableMap instance</dt><dd><p>therefore declares an integer-valued mapping with finite domain.</p>
</dd>
<dt>Every VariableMap instance should be able to tell the map’s domain, codomain, and the mapping itself, with the</dt><dd><p>former two in the format of set of integers, and the latter one in the format of dictionary mapping integers
to integers.</p>
</dd>
<dt>The domain and codomain are assumed fixed, so they should be provided during initialization. The mapping can</dt><dd><p>be computed lazily at runtime and returned by get_map(). This is to allow dynamic mappings such as
neural attention modules.</p>
</dd>
<dt>Only injective mapping can be accepted. This is because the semantic of mapping two relational variable’s values</dt><dd><p>to a single value can be ill-defined. The injectivity is checked during set_map() by comparing the
cardinality of the image and the cardinality of the domain.</p>
</dd>
</dl>
<dl class="py method">
<dt id="pysigma.structures.VariableMap.get_inverse_map">
<code class="sig-name descname">get_inverse_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.VariableMap.get_inverse_map" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the inverse map’s mapping dictionary, the inverse map’s domain (original map’s image), and the</dt><dd><p>inverse map’s image (should be the same as the original map’s domain)</p>
</dd>
</dl>
<p>Note that because injectivity is guaranteed, computing an inverse map is possible.</p>
<p>If dynamic, then call set_map() to re-compute the dict first, otherwise return the cached one.</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.structures.VariableMap.get_map">
<code class="sig-name descname">get_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.VariableMap.get_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mapping dictionary, the map’s domain, and the map’s image.</p>
<p>If dynamic, then call set_map() to re-compute the dict first, otherwise return the cached one.</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.structures.VariableMap.set_map">
<code class="sig-name descname">set_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.structures.VariableMap.set_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self.map by obtaining the mapping dictionary from self.mapping_func</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysigma.utils">
<span id="pysigma-utils-module"></span><h2>pysigma.utils module<a class="headerlink" href="#module-pysigma.utils" title="Permalink to this headline">¶</a></h2>
<p>Utility functions</p>
<dl class="py class">
<dt id="pysigma.utils.DistributionServer">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.utils.</code><code class="sig-name descname">DistributionServer</code><a class="headerlink" href="#pysigma.utils.DistributionServer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="simple">
<dt>Serving distribution class dependent utilities</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Conversion between PyTorch distribution parameters and distribution instance:</dt><dd><p>param2dist(), dist2param()</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Translation between PyTorch distribution parameters and natural parameters for exponential family</dt><dd><dl class="simple">
<dt>distribution:</dt><dd><p>natural2exp_dist(), exp_dist2natural()</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Get vector of moments from a given distribution instance:</dt><dd><p>get_moments()</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Draw particles from  distribution instance:</dt><dd><p>draw_particles()</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Get log probability density from given particles:</dt><dd><p>log_pdf()</p>
</dd>
</dl>
</li>
<li><p>Get the norm of the KL divergence of two batched distributions</p></li>
</ul>
</dd>
<dt>Certain distribution classes require special handling, for example for those categorized as finite discrete,</dt><dd><p>particle values will be drawn uniformly, covering every value in the RV’s value domain once and only once,
while assigning each particle its probability mass as its particle weight.</p>
</dd>
</dl>
<p>Therefore we delegate all such special handlings to this class on an individual basis.</p>
<dl class="simple">
<dt>Note that input and output will conform to the format understandable by PyTorch’s distribution class. To</dt><dd><p>translate to and from formats compatible to PySigma’s predicate knowledge, use KnowledgeTranslator class</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_dist2param">
<code class="sig-name descname">dict_dist2param</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_dist2param" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_draw_particles">
<code class="sig-name descname">dict_draw_particles</code><em class="property"> = {&lt;class 'torch.distributions.categorical.Categorical'&gt;: &lt;classmethod object&gt;}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_draw_particles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_exp_dist2natural">
<code class="sig-name descname">dict_exp_dist2natural</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_exp_dist2natural" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_exp_param2natural">
<code class="sig-name descname">dict_exp_param2natural</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_exp_param2natural" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_get_moments">
<code class="sig-name descname">dict_get_moments</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_get_moments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_log_pdf">
<code class="sig-name descname">dict_log_pdf</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_log_pdf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_natural2exp_dist">
<code class="sig-name descname">dict_natural2exp_dist</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_natural2exp_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_natural2exp_param">
<code class="sig-name descname">dict_natural2exp_param</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_natural2exp_param" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="pysigma.utils.DistributionServer.dict_param2dist">
<code class="sig-name descname">dict_param2dist</code><em class="property"> = {}</em><a class="headerlink" href="#pysigma.utils.DistributionServer.dict_param2dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.dist2param">
<em class="property">classmethod </em><code class="sig-name descname">dist2param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.dist2param" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion from distribution instance to PyTorch distribution parameters
Return a parameter tensor</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.draw_particles">
<em class="property">classmethod </em><code class="sig-name descname">draw_particles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist</span></em>, <em class="sig-param"><span class="n">num_particles</span></em>, <em class="sig-param"><span class="n">b_shape</span></em>, <em class="sig-param"><span class="n">e_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.draw_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: Gibbs sampling procedure
Draw a given number of particles from the given batch of distribution instances. Return a tuple:</p>
<blockquote>
<div><p>(particles, weights, sampling_log_densities)</p>
</div></blockquote>
<dl class="simple">
<dt>The Gibbs’ Sampling procedure is used to draw a single list of particles that will be used by each</dt><dd><p>distribution instance in the batch to derive individual weights by importance weighting.</p>
</dd>
</dl>
<p>Particles drawn are in the format compatible with PyTorch’s distribution class</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.exp_dist2natural">
<em class="property">classmethod </em><code class="sig-name descname">exp_dist2natural</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.exp_dist2natural" title="Permalink to this definition">¶</a></dt>
<dd><p>Composition of exp_param2natural() with dist2param()
Return a parameter tensor</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.exp_param2natural">
<em class="property">classmethod </em><code class="sig-name descname">exp_param2natural</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist_class</span></em>, <em class="sig-param"><span class="n">exp_params</span></em>, <em class="sig-param"><span class="n">b_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.exp_param2natural" title="Permalink to this definition">¶</a></dt>
<dd><p>Translation from PyTorch distribution parameters to natural parameters for exponential family
Return a parameter tensor</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.get_moments">
<em class="property">classmethod </em><code class="sig-name descname">get_moments</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist</span></em>, <em class="sig-param"><span class="n">n_moments</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.get_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Get vector of moments from a given distribution instance</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.kl_norm">
<em class="property">classmethod </em><code class="sig-name descname">kl_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist1</span></em>, <em class="sig-param"><span class="n">dist2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.kl_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the norm of the KL divergence of two given batched distributions</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.log_pdf">
<em class="property">classmethod </em><code class="sig-name descname">log_pdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist</span></em>, <em class="sig-param"><span class="n">particles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.log_pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the log pdf of the given particles w.r.t. the given distribution instance</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.natural2exp_dist">
<em class="property">classmethod </em><code class="sig-name descname">natural2exp_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist_class</span></em>, <em class="sig-param"><span class="n">natural_params</span></em>, <em class="sig-param"><span class="n">b_shape</span></em>, <em class="sig-param"><span class="n">e_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.natural2exp_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Composition of param2dist() with natural2exp_param()
Return a distribution instance</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.natural2exp_param">
<em class="property">classmethod </em><code class="sig-name descname">natural2exp_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist_class</span></em>, <em class="sig-param"><span class="n">natural_params</span></em>, <em class="sig-param"><span class="n">b_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.natural2exp_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Translation from natural parameters to PyTorch distribution parameters for exponential family
Return a parameter tensor</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.param2dist">
<em class="property">classmethod </em><code class="sig-name descname">param2dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist_class</span></em>, <em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">b_shape</span></em>, <em class="sig-param"><span class="n">e_shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.param2dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion from PyTorch distribution parameters to distribution instance
Return a distribution instance</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.DistributionServer.transform_param">
<em class="property">classmethod </em><code class="sig-name descname">transform_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em>, <em class="sig-param"><span class="n">dist_class</span></em>, <em class="sig-param"><span class="n">trans</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.DistributionServer.transform_param" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: implement
Return the parameter of the transformed distribution</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pysigma.utils.KnowledgeTranslator">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.utils.</code><code class="sig-name descname">KnowledgeTranslator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist_class</span></em>, <em class="sig-param"><span class="n">var_sizes</span></em>, <em class="sig-param"><span class="n">var_constraints</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.KnowledgeTranslator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="simple">
<dt>knowledge translator class. Translate knowledge tensors between the forms understandable by Predicate and that</dt><dd><p>understandable by PyTorch’s distribution class. This includes both event particle tensors and parameter
tensors.</p>
</dd>
<dt>Different distribution class requires different handling, but in general values for multiple random variables</dt><dd><p>(potentially of different sizes) will be concatenated together to form the last dimension of event samples
that can be interpreted by PyTorch. Therefore when translating back to Predicate knowledge format, what
is returned is a TUPLE of tensors, size of which equal to the number of RVs, and each tensor within which
corresponds to one RV’s value assignment respectively. Similarly, what is taken when translating from
Predicate knowledge to PyTorch’s knowledge is also a tuple of tensors</p>
</dd>
<dt>A translator instance should be instantiated and hold by each Predicate. When instantiated, also check if</dt><dd><p>provided var_sizes and var_constraints are compatible with dist_class. This is also distribution class
dependent therefore needs individual implementation.</p>
</dd>
</dl>
<dl class="py method">
<dt id="pysigma.utils.KnowledgeTranslator.event2pred_event">
<code class="sig-name descname">event2pred_event</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.KnowledgeTranslator.event2pred_event" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Translate event particles from the format understandable by PyTorch to the format understandable by</dt><dd><p>Predicate</p>
</dd>
</dl>
<p>Take as input a single torch tensor.
Return a tuple of torch tensors, each corresponding to one RV’s value assignment</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.KnowledgeTranslator.event2torch_event">
<code class="sig-name descname">event2torch_event</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">particles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.KnowledgeTranslator.event2torch_event" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Translate event particles from the format understandable by Predicate to the format understandable by</dt><dd><p>PyTorch</p>
</dd>
</dl>
<p>Take as input a tuple of torch tensors. Check that sizes of last dimensions equal to sizes of RVs
Return a single torch tensor.</p>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.KnowledgeTranslator.param2pred_event">
<code class="sig-name descname">param2pred_event</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.KnowledgeTranslator.param2pred_event" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Translate parameters from the format understandable by PyTorch to the format understandable by</dt><dd><p>Predicate</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pysigma.utils.KnowledgeTranslator.param2torch_param">
<code class="sig-name descname">param2torch_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.KnowledgeTranslator.param2torch_param" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Translate parameters from the format understandable by Predicate to the format understandable by</dt><dd><p>PyTorch</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pysigma.utils.extern_name">
<code class="sig-prename descclassname">pysigma.utils.</code><code class="sig-name descname">extern_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">struc_type</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.extern_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse operation of intern_name</p>
</dd></dl>

<dl class="py function">
<dt id="pysigma.utils.intern_name">
<code class="sig-prename descclassname">pysigma.utils.</code><code class="sig-name descname">intern_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">struc_type</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.utils.intern_name" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Add prefix and brackets to transform user provided structure name to internal name</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Structure name</p></li>
<li><p><strong>struc_type</strong> – one of “type”, “predicate”, or “conditional</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>processed name</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pysigma">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pysigma" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>PySigma package init file. Include definition of the Sigma class, the top-level interface to Sigma cognitive</dt><dd><p>architecture.</p>
</dd>
</dl>
<dl class="py class">
<dt id="pysigma.Sigma">
<em class="property">class </em><code class="sig-prename descclassname">pysigma.</code><code class="sig-name descname">Sigma</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Sigma’s cognitive interface. User should instantiate this class to create a Sigma model (program).</p>
<p>Implements Sigma compiler that translates cognitive languages into underlying factor graph representations.</p>
<dl class="simple">
<dt>Graph compilation is eager, i.e., as soon as a predicate or a conditional is added, the corresponding subgraph</dt><dd><p>will be compiled and added to the graphical architecture. This is in support of future research on structure
learning.</p>
</dd>
</dl>
<dl class="py method">
<dt id="pysigma.Sigma.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">structure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.add_conditional">
<code class="sig-name descname">add_conditional</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.add_conditional" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.add_predicate">
<code class="sig-name descname">add_predicate</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.add_predicate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.add_type">
<code class="sig-name descname">add_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.add_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.decide">
<code class="sig-name descname">decide</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_cycles</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.decide" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.perceive">
<code class="sig-name descname">perceive</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicates</span></em>, <em class="sig-param"><span class="n">messages</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.perceive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.print_combined_action">
<code class="sig-name descname">print_combined_action</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.print_combined_action" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.print_predicate_memory">
<code class="sig-name descname">print_predicate_memory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicates</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.print_predicate_memory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.set_assumption">
<code class="sig-name descname">set_assumption</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicates</span></em>, <em class="sig-param"><span class="n">priors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.set_assumption" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.set_evidence">
<code class="sig-name descname">set_evidence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicate</span></em>, <em class="sig-param"><span class="n">evidence</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.set_evidence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="pysigma.Sigma.set_perception">
<code class="sig-name descname">set_perception</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicates</span></em>, <em class="sig-param"><span class="n">perceive_funcs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysigma.Sigma.set_perception" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pysigma.cosine_similarity">
<code class="sig-prename descclassname">pysigma.</code><code class="sig-name descname">cosine_similarity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span> &#x2192; Tensor<a class="headerlink" href="#pysigma.cosine_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns cosine similarity between x1 and x2, computed along dim.</p>
<div class="math notranslate nohighlight">
\[\text{similarity} = \dfrac{x_1 \cdot x_2}{\max(\Vert x_1 \Vert _2 \cdot \Vert x_2 \Vert _2, \epsilon)}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> (<em>Tensor</em>) – First input.</p></li>
<li><p><strong>x2</strong> (<em>Tensor</em>) – Second input (of size matching x1).</p></li>
<li><p><strong>dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Dimension of vectors. Default: 1</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em>) – Small value to avoid division by zero.
Default: 1e-8</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Shape:</dt><dd><ul class="simple">
<li><p>Input: <span class="math notranslate nohighlight">\((\ast_1, D, \ast_2)\)</span> where D is at position <cite>dim</cite>.</p></li>
<li><p>Output: <span class="math notranslate nohighlight">\((\ast_1, \ast_2)\)</span> where 1 is at position <cite>dim</cite>.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">input1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">input2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cosine_similarity</span><span class="p">(</span><span class="n">input1</span><span class="p">,</span> <span class="n">input2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Jincheng Zhou, Yunzhe Wang, Volkan Ustun, Paul Rosenbloom

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>