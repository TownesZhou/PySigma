

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pysigma.graphical.alpha_beta_nodes &mdash; PySigma  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> PySigma
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/intro.html">Introduction and Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../introduction/getting-started.html">Getting Started</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references/index.html">API References</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../references/cognitive.html">Cognitive Language Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#type">Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#predicate">Predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#conditional">Conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#variablemap">VariableMap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#factorfunction">FactorFunction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#summarization">Summarization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../references/graphical/index.html">Graphical Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/data-structures.html">Basic Data Structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#variable-metatypes">Variable Metatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#variable">Variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#message-types">Message Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#message">Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#linkdata">LinkData</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html">Abstract Base Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#node">Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#factor-node">Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#variable-node">Variable Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#alpha-factor-node">Alpha Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#beta-factor-node">Beta Factor Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html">Predicate Subgraph Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#working-memory-variable-node">Working Memory Variable Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#long-term-memory-factor-node">Long-Term Memory Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#parameter-store-factor-node">Parameter Store Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#perceptual-buffer-node">Perceptual Buffer Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#working-memory-factor-node">Working Memory Factor Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html">Conditional Subgraph Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#expansion-summarization-factor-node">Expansion / Summarization Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#relational-mapping-factor-node">Relational Mapping Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#concatenation-marginalization-transformation-factor-node">Concatenation, Marginalization, &amp; Transformation Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#event-resolution-factor-node">Event Resolution Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#beta-join-factor-node">Beta Join Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#gamma-factor-node">Gamma Factor Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/other-structural-nodes.html">Other Structural Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/other-structural-nodes.html#default-factor-node">Default Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/other-structural-nodes.html#default-variable-node">Default Variable Node</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../references/utils.html">Utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../references/utils.html#utility-functions">Utility Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/utils.html#distributionserver">DistributionServer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/utils.html#knowledgeserver">KnowledgeServer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Example Models</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PySigma</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pysigma.graphical.alpha_beta_nodes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pysigma.graphical.alpha_beta_nodes</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    All nodes related to a conditional subgraph</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.distributions</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">torch.distributions.constraints</span> <span class="kn">import</span> <span class="n">Constraint</span>
<span class="kn">from</span> <span class="nn">defs</span> <span class="kn">import</span> <span class="n">VariableMetatype</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">MessageType</span><span class="p">,</span> <span class="n">Message</span><span class="p">,</span> <span class="n">NP_EPSILON</span>
<span class="kn">from</span> <span class="nn">graphical.basic_nodes</span> <span class="kn">import</span> <span class="n">LinkData</span><span class="p">,</span> <span class="n">VariableNode</span><span class="p">,</span> <span class="n">FactorNode</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">KnowledgeServer</span>
<span class="kn">from</span> <span class="nn">structures</span> <span class="kn">import</span> <span class="n">VariableMap</span><span class="p">,</span> <span class="n">Summarization</span>


<div class="viewcode-block" id="AlphaFactorNode"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.AlphaFactorNode">[docs]</a><span class="k">class</span> <span class="nc">AlphaFactorNode</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for any factor node belonging to an alpha subgraph.</span>

<span class="sd">    Captures the commonalities of all alpha subgraph nodes:</span>

<span class="sd">    * **Topology**: an alpha node accepts up to two pairs of incoming and outgoing linkdata, with one pair propagating</span>
<span class="sd">      messages inward toward the Gamma Factor Node, and the other pair propagating messages outward toward the predicate</span>
<span class="sd">      Working Memory Variable Node.</span>
<span class="sd">    * **Admissible variable nodes**: an alpha node treats the relational variables and manipulates messages&#39; batch</span>
<span class="sd">      dimensions only, and leaves untouched the random variables and corresponding event dimensions. Therefore,</span>
<span class="sd">      incident variable nodes should have the same tuple of random variables.</span>
<span class="sd">    * **Compute pattern**: an alpha node computes outgoing messages for each pair of linkdata individually. In other</span>
<span class="sd">      words, for instance, the outgoing message to an inward outgoing link is solely dependent on the message received</span>
<span class="sd">      from the inward incoming link. Accordingly, the `compute()` method is subdivided into an `inward_compute()` and an</span>
<span class="sd">      `outward_compute()` method.</span>
<span class="sd">    * **Quiescence state**: an alpha node as a whole reaches quiescence if and only if **all** incoming linkdata do not</span>
<span class="sd">      contain new message. However, for the two subdivided method `inward_compute()` and `outward_compute()`, each of</span>
<span class="sd">      them should only be carried out if its incoming linkdata of interest contains new message.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Pairs of incoming and outgoing linkdata labeled with their directionality w.r.t. the alpha structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="AlphaFactorNode.add_link"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.AlphaFactorNode.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An alpha factor node admits at least one but no more than two pairs of incoming and outgoing linkdata. The</span>
<span class="sd">        incident variable nodes should have the same tuple of random variables. Furthermore, a ``&quot;direction&quot;`` key-ed</span>
<span class="sd">        attribute should be included in the linkdata&#39;s optional attribute map with value ``&quot;inward&quot;`` or ``&quot;outward&quot;``</span>
<span class="sd">        to indicate the message propagation direction of the linkdata. The two pairs of linkdata should have different</span>
<span class="sd">        message propagation directions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linkdata : LinkData</span>
<span class="sd">            The linkdata to be registered. Must specify a ``&quot;direction&quot;`` attribute in its optional attribute map</span>
<span class="sd">            ``linkdata.attr``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="c1"># Check random variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">=</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">==</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_vars</span>

        <span class="k">assert</span> <span class="s1">&#39;direction&#39;</span> <span class="ow">in</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span> <span class="ow">and</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;inward&#39;</span><span class="p">,</span> <span class="s1">&#39;outward&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>

        <span class="c1"># If the other ld of this ld pair has not been added, then temporarily register this ld instance directly</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">linkdata</span>
        <span class="c1"># Otherwise, take out the other ld of this ld pair from the dict and replace entry with a tuple</span>
        <span class="c1">#   Make sure that incoming ld is the first element of the tuple and outgoing ld the second element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">other_ld</span><span class="p">)</span> <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span> <span class="k">else</span> <span class="p">(</span><span class="n">other_ld</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlphaFactorNode.compute"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.AlphaFactorNode.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Carries out `inward_compute()` and `outward_compute()` individually if their corresponding incoming linkdata</span>
<span class="sd">        contains new message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Carry out directional computation</span>
        <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;inward&#39;</span> <span class="ow">and</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">new</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inward_compute</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;outward&#39;</span> <span class="ow">and</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">new</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outward_compute</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlphaFactorNode.inward_compute"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.AlphaFactorNode.inward_compute">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inward message computation. To be implemented by child class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="AlphaFactorNode.outward_compute"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.AlphaFactorNode.outward_compute">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Outward message computation. To be implemented by child class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="ESFN"><a class="viewcode-back" href="../../../references/graphical/conditional-nodes.html#pysigma.graphical.alpha_beta_nodes.ESFN">[docs]</a><span class="k">class</span> <span class="nc">ESFN</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Expansion / Summarization Factor Node</span>

<span class="sd">    This node should be connected to two DVNs that share the same set of random variables but perhaps different</span>
<span class="sd">    relational variables, with the DVN on the outward propagation side having a set of relational variables that is a</span>
<span class="sd">    subset of the set of relational variables of the DVN on the inward propagation side. The task of this node is to</span>
<span class="sd">    manipulate the incoming message&#39;s batch dimensions so that they align with the relational variable dimensions of the</span>
<span class="sd">    target DVN. Specifically:</span>

<span class="sd">    * For the inward propagation, since the target DVN may include relational variables that do not present in the</span>
<span class="sd">      source DVN, this procedure consists of **expansion** of the message&#39;s batch dimensions to make space for these</span>
<span class="sd">      missing relational variables, as well as **permutation** of the expanded dimensions so that they are in the same</span>
<span class="sd">      order as demanded by the target DVN.</span>
<span class="sd">    * For the outward propagation, it&#39;s the exact opposite. **Summarization** across the message batch dimensions</span>
<span class="sd">      associated with those un-referenced relational variables is first carried out, followed by the same</span>
<span class="sd">      **permutation** procedure.</span>

<span class="sd">    The summarization step can be thought of as a search or optimization problem, for which one finds a single</span>
<span class="sd">    distribution instance that best &quot;summarizes&quot; the behaviors of an entire (finite) space of distribution instances,</span>
<span class="sd">    where the dimensions of the space are spanned by the un-referenced relational variables. The semantics of such</span>
<span class="sd">    summarization can vary depending on the use case. The default summarization procedure implements the semantics of</span>
<span class="sd">    &quot;combining&quot; distributions, i.e.::</span>

<span class="sd">        p(x) = p_1(x) * p_2(x) * ... * p_k(x)</span>

<span class="sd">    but a custom summarization procedure can also be declared using the `sum_op` argument to implement other semantics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this node</span>
<span class="sd">    sum_op : Summarization, optional</span>
<span class="sd">        The summarization operation functor to be called during outward propagation. Defaults to ``None``, in which case</span>
<span class="sd">        the &quot;combination&quot; semantic is implemented.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sum_op</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sum_op</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Necessary data structure:</span>

<span class="sd">            :param sum_op:      None or a Summarization instance. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ESFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Expansion / Summarization Factor Node&quot;</span>

        <span class="k">assert</span> <span class="n">sum_op</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_op</span><span class="p">,</span> <span class="n">Summarization</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sum_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Summarization operation using Summarization instance is not yet implemented.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sum_op</span> <span class="o">=</span> <span class="n">sum_op</span>

<div class="viewcode-block" id="ESFN.inward_compute"><a class="viewcode-back" href="../../../references/graphical/conditional-nodes.html#pysigma.graphical.alpha_beta_nodes.ESFN.inward_compute">[docs]</a>    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands and permutes the incoming message&#39;s relational variable dimensions to match the target outgoing</span>
<span class="sd">        relational variable dimensions.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the set of source DVN&#39;s relational variables is not a subset of the set of target DVN&#39;s relational</span>
<span class="sd">            variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_vars</span><span class="p">,</span> <span class="n">out_rel_vars</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span>
        <span class="c1"># Check that the set of relational variables of incoming message is a subset of that of outgoing message</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">)),</span> \
            <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: during inward propagation, expect the set of source DVN&#39;s relational variables being a subset of &quot;</span> \
            <span class="s2">&quot;the set of target DVN&#39;s relational variables. Found variables </span><span class="si">{}</span><span class="s2"> from incoming linkdata, but variables &quot;</span> \
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> from outgoing linkdata.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">in_rel_vars</span><span class="p">,</span> <span class="n">out_rel_vars</span><span class="p">)</span>

        <span class="c1"># Keep a running list of variables</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span>

        <span class="c1"># For every relational variable in out_rel_var_list that is not in in_rel_var_list, unsqueeze a dimension of the</span>
        <span class="c1">#   message as the last dimension.</span>
        <span class="k">for</span> <span class="n">rel_var</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rel_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_rel_vars</span><span class="p">:</span>
                <span class="c1"># Unsqueeze message</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Append the pt_var to the end of running var list</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_var</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">)</span>

        <span class="c1"># Permute message batch dimension so that it matches the order given by out_rel_var_list</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>

        <span class="c1"># Expand to full relational variable dimension shape</span>
        <span class="n">target_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">])</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_expand</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="ESFN.outward_compute"><a class="viewcode-back" href="../../../references/graphical/conditional-nodes.html#pysigma.graphical.alpha_beta_nodes.ESFN.outward_compute">[docs]</a>    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Summarizes over incoming message&#39;s un-referenced relational variable dimensions and permute to match the</span>
<span class="sd">        target outgoing relational variable dimensions.</span>

<span class="sd">        The summarization semantic is defined by the sum_op specified during initialization. If sum_op is None,</span>
<span class="sd">        uses default summarization semantic defined at the Message level.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the set of source DVN&#39;s relational variables is not a subset of the set of target DVN&#39;s relational</span>
<span class="sd">            variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_vars</span><span class="p">,</span> <span class="n">out_rel_vars</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span>
        <span class="c1"># Check that the set of relational variables of outgoing message is a subset of that of incoming message</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">))</span>

        <span class="c1"># Keep a running list of variables</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span>

        <span class="c1"># Summarize using custom sum_op</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Flatten both the group of dimensions to be summarized over and the group of other dimensions. Put the</span>
            <span class="c1">#   former as the first dimension and the latter as the last batch dimension</span>
            <span class="n">sum_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">)</span>
            <span class="n">other_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sum_dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># First flatten sum_dims, then other_dims, so that flattened sum_dims will be the first dim</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_flatten</span><span class="p">(</span><span class="n">sum_dims</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_flatten</span><span class="p">(</span><span class="n">other_dims</span><span class="p">)</span>
                <span class="c1"># Process using the sum_op</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_op</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span><span class="p">)</span>
                <span class="c1"># Reshape</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_reshape</span><span class="p">(</span><span class="n">other_dims</span><span class="p">)</span>

        <span class="c1"># Otherwise if sum_op is None, carry out default summarization</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Iterate over all relational variables not referenced by out_rel_var_list</span>
            <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">in_rel_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pt_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">:</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                    <span class="c1"># Summarize over the message batch dimension</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_summarize</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="c1"># Remove the variable from the running list</span>
                    <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">)</span>

        <span class="c1"># Permute message dimension so that it matches the outgoing relational variable order</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RMFN"><a class="viewcode-back" href="../../../references/graphical/conditional-nodes.html#pysigma.graphical.alpha_beta_nodes.RMFN">[docs]</a><span class="k">class</span> <span class="nc">RMFN</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Relation Variable Mapping Node</span>

<span class="sd">    Converts predicate arguments from and to pattern variables. Applies relational variable&#39;s `VariableMap` (if</span>
<span class="sd">    specified) by manipulating message batch dimensions. This node can thus implements the semantic of inner-pattern</span>
<span class="sd">    relational variable matching.</span>

<span class="sd">    Mappings between the source relational arguments and target relational variables as well as that from source</span>
<span class="sd">    relational arguments to `VariableMap` instances need to be provided.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this node</span>
<span class="sd">    arg2var : dict</span>
<span class="sd">        Dictionary mapping predicate relational argument `Variable` instance to pattern relational variable `Variable`</span>
<span class="sd">        instance.</span>
<span class="sd">    var2arg : dict</span>
<span class="sd">        Dictionary mapping pattern relational variable `Variable` instance to LIST of predicate relational argument</span>
<span class="sd">        `Variable` instances. The list length would be longer than 1 if the relational variable is being referenced</span>
<span class="sd">        by multiple arguments.</span>
<span class="sd">    arg2var_map : dict</span>
<span class="sd">        Dictionary mapping predicate relational argument `Variable` instance to a `VariableMap` instance if one is</span>
<span class="sd">        specified for this argument. If an argument is not associated with a `VariableMap`, it should not appear in this</span>
<span class="sd">        dictionary.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    arg2var</span>
<span class="sd">    var2arg</span>
<span class="sd">    arg2var_map</span>
<span class="sd">    arg_set : set</span>
<span class="sd">        The set of predicate argument `Variable` instances. Obtained from the keys of `arg2var`.</span>
<span class="sd">    var_set : set</span>
<span class="sd">        The set of pattern variable `Variable` instances. Obtained from the keys of `var2arg`.</span>
<span class="sd">    arg2var_map_tuple : dict</span>
<span class="sd">        Obtained from `arg2var_map`. Mapping from predicate argument to the mapping dictionary (if a `VariableMap` is</span>
<span class="sd">        specified).</span>
<span class="sd">    arg2var_map_inv_tuple : dict</span>
<span class="sd">        Obtained from `arg2var_map`. Mapping from predicate argument to the INVERSE mapping dictionary (if a</span>
<span class="sd">        `VariableMap` is specified).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">arg2var</span><span class="p">,</span> <span class="n">var2arg</span><span class="p">,</span> <span class="n">arg2var_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Relation Variable Mapping Node&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg2var</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">arg2var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arg2var</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var2arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var2arg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">var2arg</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg2var_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">arg2var_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">VariableMap</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arg2var_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span> <span class="o">=</span> <span class="n">arg2var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span> <span class="o">=</span> <span class="n">var2arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map</span> <span class="o">=</span> <span class="n">arg2var_map</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arg_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Sanity check whether the variables given in the three dicts are compatible.</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_set</span>
        <span class="n">arg_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arg_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">arg_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">arg_list</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">arg_set</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_set</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_set</span><span class="p">)</span>

        <span class="c1"># Obtain mapping dictionary and inverse mapping dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="n">var_map</span><span class="o">.</span><span class="n">get_map</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_inv_tuple</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="n">var_map</span><span class="o">.</span><span class="n">get_inverse_map</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<div class="viewcode-block" id="RMFN.inward_compute"><a class="viewcode-back" href="../../../references/graphical/conditional-nodes.html#pysigma.graphical.alpha_beta_nodes.RMFN.inward_compute">[docs]</a>    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inward computation. Converts predicate relational arguments to pattern relational variables. Applies mappings</span>
<span class="sd">        to relational variable&#39;s values, if specified.</span>

<span class="sd">        For inward direction, we are assuming this is used in condition or condact patterns. Accordingly, the inverse</span>
<span class="sd">        mapping should be used to map predicate arguments to pattern variables.</span>

<span class="sd">        Will check anyway if domain and image of the inverse map agree with the size range of the predicate argument</span>
<span class="sd">        and pattern variable respectively. However to be user friendly this should be checked beforehand by compiler.</span>

<span class="sd">        Note that domain should be a subset of predicate argument size range, but image should be exactly equal to</span>
<span class="sd">        the pattern variable size range</span>

<span class="sd">        The computations to be carried out can be summarized in three steps: map/broaden, diagonalize, &amp; permute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_vars</span><span class="p">,</span> <span class="n">out_rel_vars</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span>

        <span class="c1"># Check that given data structures agree with variable lists of the incident variable node</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_set</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_set</span>
        <span class="c1"># Check that mapping&#39;s domain and image agree with variables&#39; sizes</span>
        <span class="c1">#   Note that for inward computation we are using the inverse map</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map_tuple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_inv_tuple</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pat_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">var_map_tuple</span>
            <span class="k">assert</span> <span class="n">domain</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span><span class="p">))),</span> \
                <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: The VariableMap declared on the predicate argument </span><span class="si">{}</span><span class="s2"> would induce an image that exceeds the &quot;</span> \
                <span class="s2">&quot;argument&#39;s value range. The argument&#39;s value range is </span><span class="si">{}</span><span class="s2">, but found image </span><span class="si">{}</span><span class="s2">.&quot;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">domain</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">image</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> \
                <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: The VariableMap declared on the predicate argument </span><span class="si">{}</span><span class="s2"> should have a domain equal to the value &quot;</span>\
                <span class="s2">&quot;range of the associated pattern variable </span><span class="si">{}</span><span class="s2">. The pattern variable&#39;s value range is </span><span class="si">{}</span><span class="s2">, but found &quot;</span> \
                <span class="s2">&quot;VariableMap domain </span><span class="si">{}</span><span class="s2">&quot;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pat_var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">image</span><span class="p">)</span>

        <span class="c1"># 1. First, translate predicate arguments to pattern variables. This step involves broadening the variable</span>
        <span class="c1">#    dimension if predicate argument size is smaller than pattern variable size, or map predicate argument</span>
        <span class="c1">#    values to pattern variable values if a VariableMap is specified for the given predicate argument.</span>
        <span class="c1">#</span>
        <span class="c1">#    For the mapping we should use original forward mapping in combination with batch_index_select(), because we</span>
        <span class="c1">#    are selecting &quot;image&quot; to place in &quot;domain&quot;, in the order mandated by domain.</span>
        <span class="c1">#</span>
        <span class="c1">#    For example, if the VariableMap is defined as  2 * var + 3 |-&gt; arg , and `var` range is [0, 2], we will be</span>
        <span class="c1">#    selecting from the incoming message, the slices with indices 3, 5, 8, to place onto indices 0, 1, 2 of the</span>
        <span class="c1">#    outgoing message. To use batch_index_select(), we gather the indices [3, 5, 8] as the argument, which are</span>
        <span class="c1">#    obtained from the forward mapping dictionary.</span>
        <span class="c1">#</span>
        <span class="c1">#    Note that we have guaranteed that forward mapping&#39;s domain is equal to pattern variable&#39;s size range</span>
        <span class="c1">#    A running list of variables is maintained to keep track of variable dimensions</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">):</span>
            <span class="n">pat_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
            <span class="c1"># Apply map if VariableMap is specified</span>
            <span class="k">if</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">map_dict</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">map_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span>
                                       <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_index_select</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="c1"># Broaden the variable dimension size if currently it is smaller than the pattern variable&#39;s size</span>
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_broaden</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="c1"># Change predicate argument to pattern variable Variable instance</span>
            <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_var</span>

        <span class="c1"># 2. The step above guarantees that for any dimensions that share the same pattern variable, their axis values</span>
        <span class="c1">#       are semantically identical to the pattern variable&#39;s value.</span>
        <span class="c1">#    Now we should collapse the dimensions that share the same pattern variable, by selecting the diagonal</span>
        <span class="c1">#       entries across these dimensions.</span>
        <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">mapped_var_list</span><span class="p">:</span>
            <span class="c1"># Current position of pt_var in the moving mapped_var_list. Using enumerate() iterator will not return</span>
            <span class="c1">#   index of value w.r.t. a moving list</span>
            <span class="n">dim1</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
            <span class="c1"># Find any repetition in later part of the list</span>
            <span class="k">if</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="c1"># Current index of the first repetition</span>
                <span class="n">dim2</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span> <span class="o">+</span> <span class="n">dim1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Remove these two entries from the list</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                <span class="c1"># Append one to the end</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                <span class="c1"># Selecting diagonal entries in message</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_diagonal</span><span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">)</span>

        <span class="c1"># Check that we have produced all the target relational variables, albeit with a different order perhaps</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">)</span>

        <span class="c1"># 3. With all predicate argument dimension converted to pattern variable dimensions and all repetitions</span>
        <span class="c1">#       diagonalized, we guarantee that all predicate variable appears in mapped_var_list.</span>
        <span class="c1">#    The last thing to do is to permute the batch dimensions so that the processed message&#39;s dimension match</span>
        <span class="c1">#       exactly with out_rel_var_list</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">])</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMFN.outward_compute"><a class="viewcode-back" href="../../../references/graphical/conditional-nodes.html#pysigma.graphical.alpha_beta_nodes.RMFN.outward_compute">[docs]</a>    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Outward computation. Converts pattern relational variables to predicate relational arguments. Applies</span>
<span class="sd">        mappings to relational variable&#39;s values, if specified.</span>

<span class="sd">        For outward direction, we are assuming this is used in action or condact patterns. Accordingly, the</span>
<span class="sd">        original forward mapping should be used to map pattern variables to predicate arguments.</span>

<span class="sd">        Will check anyway if domain and image of the forward map agree with the size range of the predicate argument</span>
<span class="sd">        and pattern variable respectively. However to be user friendly this should be checked beforehand by</span>
<span class="sd">        compiler.</span>

<span class="sd">        Note that image of the map should be a subset of predicate argument size range, but its domain should be</span>
<span class="sd">        exactly equal to the pattern variable size range.</span>

<span class="sd">        The computations to be carried out can be summarized in three steps: un-diagonalize, map/narrow, &amp; permute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_vars</span><span class="p">,</span> <span class="n">out_rel_vars</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span>

        <span class="c1"># Check that given data structures agree with variable lists of the incident variable node</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_set</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_set</span>
        <span class="c1"># Check that mapping&#39;s domain and image agree with variables&#39; sizes</span>
        <span class="c1">#   For outward computation we are using the forward map</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map_tuple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pat_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">var_map_tuple</span>
            <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span><span class="p">))),</span> \
                <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: The VariableMap declared on the predicate argument </span><span class="si">{}</span><span class="s2"> would induce an image that exceeds the &quot;</span> \
                <span class="s2">&quot;argument&#39;s value range. The argument&#39;s value range is </span><span class="si">{}</span><span class="s2">, but found image </span><span class="si">{}</span><span class="s2">.&quot;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">image</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">domain</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> \
                <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: The VariableMap declared on the predicate argument </span><span class="si">{}</span><span class="s2"> should have a domain equal to the value &quot;</span>\
                <span class="s2">&quot;range of the associated pattern variable </span><span class="si">{}</span><span class="s2">. The pattern variable&#39;s value range is </span><span class="si">{}</span><span class="s2">, but found &quot;</span> \
                <span class="s2">&quot;VariableMap domain </span><span class="si">{}</span><span class="s2">&quot;</span> \
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pat_var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">domain</span><span class="p">)</span>

        <span class="c1"># 1. First, translate pattern variables to predicate arguments. This step involves unbinding the predicate</span>
        <span class="c1">#       variables that are referenced by multiple predicate arguments.</span>
        <span class="c1">#    Computationally, this is achieved by un-diagonalize, or embed entries along that predicate variables&#39;</span>
        <span class="c1">#       dimension into a 2D plane (higher dimensional space if there are more than 2 such predicate arguments).</span>
        <span class="c1">#    A running list of variables is maintained to keep track of variable dimensions</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">in_rel_vars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">mapped_var_list</span><span class="p">:</span>
            <span class="c1"># Look up how many predicate arguments reference this single pattern variable. If only 1, simply change</span>
            <span class="c1">#   variable. Otherwise, need to do more</span>
            <span class="c1"># Use .index() to get the position of current variable, instead of from enumerate() iterator, because the</span>
            <span class="c1">#   the latter does not keep up with a running list.</span>
            <span class="n">dim1</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span><span class="p">[</span><span class="n">pt_var</span><span class="p">]</span>
            <span class="n">num_shared</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">num_shared</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="c1"># Switch pattern variable to predicate argument in-place anyway. If the pattern variable is associated with</span>
            <span class="c1">#   multiple predicate arguments, process further.</span>
            <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim1</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num_shared</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Iterate over rest of the associated predicate arguments</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="c1"># Only arguments from the second one will be processed. First associated argument stays in-place.</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Un-diagonalize the message by embedding the entries along the i-th dimension of the original</span>
                    <span class="c1">#   message into a 2D plane specified by the i-th and the last dimension of the new message</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_diag_embed</span><span class="p">(</span><span class="n">diag_dim</span><span class="o">=</span><span class="n">dim1</span><span class="p">,</span> <span class="n">target_dim1</span><span class="o">=</span><span class="n">dim1</span><span class="p">,</span> <span class="n">target_dim2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># This corresponds to append the other dimension to the end, so we append the currently referenced</span>
                    <span class="c1">#   predicate argument Variable instance to the running variable list</span>
                    <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_vars</span><span class="p">)</span>

        <span class="c1"># 2. The step above guarantees a symbolic one-to-one mapping between message dimensions and predicate arguments&#39;</span>
        <span class="c1">#       variable dimensions. We now need to narrow the variable dimension if the predicate argument&#39;s size is</span>
        <span class="c1">#       smaller than the associated pattern variable&#39;s size, or to map pattern variable&#39;s value to predicate</span>
        <span class="c1">#       argument&#39;s value if a VariableMap is specified.</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">):</span>
            <span class="n">pat_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
            <span class="c1"># Apply map if VariableMap is specified</span>
            <span class="k">if</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">map_dict</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">map_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span>
                                       <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_index_put</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="c1"># Broaden the variable dimension size if currently it is smaller than the pattern variable&#39;s size</span>
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pred_arg</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_narrow</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pred_arg</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># 3. Finally, with all pattern variables converted to predicate arguments and the values are now with respect to</span>
        <span class="c1">#       the predicate arguments, the last thing to do is to permute the batch dimensions so that the processed</span>
        <span class="c1">#       message&#39;s dimensions match exactly with out-_rel_var_list</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pred_arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_vars</span><span class="p">])</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BetaFactorNode"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.BetaFactorNode">[docs]</a><span class="k">class</span> <span class="nc">BetaFactorNode</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for nodes belonging to the beta subgraph of a conditional.</span>

<span class="sd">    Captures the commonalities of beta subgraph nodes:</span>

<span class="sd">    * **Topology**: a beta node is typically connected to up to two pairs of *lists* of incoming and outgoing links,</span>
<span class="sd">      with each pair designated a unique message propagation direction. In other words, contrast to an alpha node, a</span>
<span class="sd">      beta node for example may be connected to multiple inward incoming links. However, the message propagation</span>
<span class="sd">      directions of the links are well grouped in that, if there is inward incoming link, then there must be a inward</span>
<span class="sd">      outgoing link.</span>
<span class="sd">    * **Admissible variable nodes**: a beta factor node treats the random variables only, and leave untouched the</span>
<span class="sd">      relational variables that should have been processed by alpha factor nodes. Thus, incident variable nodes should</span>
<span class="sd">      have the same tuple of relational variables.</span>
<span class="sd">    * **Compute pattern**: similar to an alpha factor node. However, since there may be multiple incoming links with</span>
<span class="sd">      same message propagation direction, each subdivided compute method, i.e., `inward_compute()` and</span>
<span class="sd">      `outward_compute()`, would be executed if **all** of its incoming linkdata contain new messages.</span>
<span class="sd">    * **Quiescence state**: similar to an alpha factor node</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Pairs of incoming and outgoing linkdata list with their messaging direction w.r.t. the beta structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;inward&#39;</span><span class="p">:</span> <span class="p">([],</span> <span class="p">[]),</span>     <span class="c1"># First list contains incoming links, and second outgoing links</span>
            <span class="s1">&#39;outward&#39;</span><span class="p">:</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BetaFactorNode.add_link"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.BetaFactorNode.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A Beta Factor Node admits at least one but no more than two pairs of lists of incoming and outgoing linkdata.</span>
<span class="sd">        The incident variable nodes should have the same tuple of random variables. Furthermore, a ``&quot;direction&quot;``</span>
<span class="sd">        key-ed attribute should be included in the linkdata&#39;s optional attribute map with value ``&quot;inward&quot;`` or</span>
<span class="sd">        ``&quot;outward&quot;`` to indicate the message propagation direction of the linkdata. The two pairs of linkdata should</span>
<span class="sd">        have different message propagation directions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linkdata : LinkData</span>
<span class="sd">            The linkdata to be registered. Must specify a ``&quot;direction&quot;`` attribute in its optional attribute map</span>
<span class="sd">            ``linkdata.attr``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="c1"># Check random variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">=</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">==</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_vars</span>

        <span class="k">assert</span> <span class="s1">&#39;direction&#39;</span> <span class="ow">in</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span> <span class="ow">and</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;inward&#39;</span><span class="p">,</span> <span class="s1">&#39;outward&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="p">[</span><span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="p">[</span><span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span></div>

<div class="viewcode-block" id="BetaFactorNode.compute"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.BetaFactorNode.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Carries out `inward_compute()` and `outward_compute()` separately only if all their corresponding incoming</span>
<span class="sd">        linkdata contains new message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="p">(</span><span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_ld_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ld_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;inward&#39;</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">in_ld</span><span class="o">.</span><span class="n">new</span> <span class="k">for</span> <span class="n">in_ld</span> <span class="ow">in</span> <span class="n">in_ld_list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inward_compute</span><span class="p">(</span><span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;outward&#39;</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">in_ld</span><span class="o">.</span><span class="n">new</span> <span class="k">for</span> <span class="n">in_ld</span> <span class="ow">in</span> <span class="n">in_ld_list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outward_compute</span><span class="p">(</span><span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="BetaFactorNode.inward_compute"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.BetaFactorNode.inward_compute">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Inward message computation. To be implemented by child class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BetaFactorNode.outward_compute"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical.alpha_beta_nodes.BetaFactorNode.outward_compute">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Outward message computation. To be implemented by child class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<span class="k">class</span> <span class="nc">CMTN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenation, Marginalization, &amp; Transformation Node</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">FVN</span><span class="p">(</span><span class="n">VariableNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filter Variable Node</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ERFN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Event Resolution Factor Node</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ECFN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Event Combination Factor Node</span>

<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Jincheng Zhou, Yunzhe Wang, Volkan Ustun, Paul Rosenbloom @ USC Institute for Creative Technologies

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>