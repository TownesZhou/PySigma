

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pysigma.graphical._nodes &mdash; PySigma  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> PySigma
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/intro.html">Introduction and Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../introduction/getting-started.html">Getting Started</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references/index.html">API References</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../references/cognitive.html">Cognitive Language Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#type">Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#predicate">Predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/cognitive.html#conditional">Conditional</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../references/graphical/index.html">Graphical Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/data-structures.html">Basic Data Structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#variable-metatypes">Variable Metatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#variable">Variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#message-types">Message Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#message">Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/data-structures.html#linkdata">LinkData</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html">Abstract Base Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#node">Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#factor-node">Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#variable-node">Variable Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#alpha-factor-node">Alpha Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/abstract-base-nodes.html#beta-factor-node">Beta Factor Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html">Predicate Subgraph Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#working-memory-variable-node">Working Memory Variable Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#long-term-memory-factor-node">Long-Term Memory Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#perceptual-buffer-node">Perceptual Buffer Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/predicate-nodes.html#working-memory-factor-node">Working Memory Factor Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html">Conditional Subgraph Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#relational-mapping-factor-node">Relational Mapping Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#expansion-summarization-factor-node">Expansion / Summarization Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#concatenation-marginalization-transformation-factor-node">Concatenation, Marginalization, &amp; Transformation Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#event-resolution-factor-node">Event Resolution Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#beta-join-factor-node">Beta Join Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/conditional-nodes.html#gamma-factor-node">Gamma Factor Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/graphical/other-structural-nodes.html">Other Structural Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/other-structural-nodes.html#default-factor-node">Default Factor Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../references/graphical/other-structural-nodes.html#default-variable-node">Default Variable Node</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../references/utils.html">Utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../references/utils.html#distributionserver">DistributionServer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../references/utils.html#knowledgeserver">KnowledgeServer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Example Models</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PySigma</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pysigma.graphical._nodes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pysigma.graphical._nodes</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    All kinds of nodes in the graphical architecture</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="k">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">torch.distributions</span> <span class="k">import</span> <span class="n">Distribution</span><span class="p">,</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">torch.distributions.constraints</span> <span class="k">import</span> <span class="n">Constraint</span>
<span class="kn">from</span> <span class="nn">defs</span> <span class="k">import</span> <span class="n">VariableMetatype</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">MessageType</span><span class="p">,</span> <span class="n">Message</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="k">import</span> <span class="n">DistributionServer</span><span class="p">,</span> <span class="n">KnowledgeServer</span>
<span class="kn">from</span> <span class="nn">structures</span> <span class="k">import</span> <span class="n">VariableMap</span><span class="p">,</span> <span class="n">Summarization</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic data structures and abstract node classes</span>
<span class="sd">        - LinkData</span>
<span class="sd">        - Node</span>
<span class="sd">        - FactorNode</span>
<span class="sd">        - VariableNode</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="LinkData"><a class="viewcode-back" href="../../../references/graphical/data-structures.html#pysigma.graphical._nodes.LinkData">[docs]</a><span class="k">class</span> <span class="nc">LinkData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Identifies the data of a directed link between a factor node and a variable node. Stores intermediate messages in</span>
<span class="sd">    its message memory.</span>

<span class="sd">    Note that links are directional, and two of such links should be specified with opposite directions to represent</span>
<span class="sd">    a bidirectional link between a factor node and a variable node.</span>

<span class="sd">    During construction of the graph, its instance should be passed to NetworkX methods as the edge data to instantiate</span>
<span class="sd">    an edge.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vn : VariableNode</span>
<span class="sd">        VariableNode instance that this link is incident to.</span>
<span class="sd">    fn : FactorNode</span>
<span class="sd">        FactorNode instance that this link is incident to.</span>
<span class="sd">    to_fn : bool</span>
<span class="sd">        True if this link is pointing toward the factor node.</span>
<span class="sd">    msg_shape : tuple of torch.Size</span>
<span class="sd">        The shape of the message to carry. Used for sanity check of message shapes. Should be in the format</span>
<span class="sd">        ``(batch_shape, param_shape, sample_shape, event_shape)``. An empty shape ``torch.Size([])`` should be used as</span>
<span class="sd">        the default none shape.</span>
<span class="sd">    epsilon : float, optional</span>
<span class="sd">        Epsilon upper bound for checking message difference.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    memory : Message or None</span>
<span class="sd">        The message memory buffer.</span>
<span class="sd">    new : bool</span>
<span class="sd">        Indicates if this link-data has received a new message in the current decision phase.</span>
<span class="sd">    vn : VariableNode</span>
<span class="sd">        The incident variable node.</span>
<span class="sd">    fn : FactorNode</span>
<span class="sd">        The incident factor node.</span>
<span class="sd">    msg_shape : tuple of torch.Size</span>
<span class="sd">        The allowable message shape, in the format ``(batch_shape, param_shape, sample_shape, event_shape)``.</span>
<span class="sd">    to_fn : bool</span>
<span class="sd">        Indicates if this link-data is pointing towards a factor node.</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Epsilon upper bound for checking message difference.</span>
<span class="sd">    attr : dict</span>
<span class="sd">        Additional special attributes specified via `kwargs` in the constructor.</span>
<span class="sd">    pretty_log : dict</span>
<span class="sd">        Pretty logging for front-end visualization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">to_fn</span><span class="p">,</span> <span class="n">msg_shape</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">10e-5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param vn:      VariableNode instance that this link is incident to</span>
<span class="sd">        :param fn:      FactorNode instance that this link is incident to</span>
<span class="sd">        :param to_fn:   True/False indicating whether this link is pointing toward a factor node</span>
<span class="sd">        :param msg_shape    Fixed message shape that this linkdata will carry. Used for checking dimensions</span>
<span class="sd">                            For Parameter message, should be (batch_shape + param_shape)</span>
<span class="sd">                            For particles message, should be (sample_shape + batch_shape + event_shape)</span>
<span class="sd">        :param epsilon:     epsilon upper bound for checking message difference using KL divergence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vn</span><span class="p">,</span> <span class="n">VariableNode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">FactorNode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg_shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">msg_shape</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_fn</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Message memory, of type Message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Whether this message is new, and haven&#39;t been read by recipient node. Of type bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Incident nodes and their variable list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vn</span> <span class="o">=</span> <span class="n">vn</span>                <span class="c1"># Of type VariableNode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>                <span class="c1"># Of type FactorNode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_shape</span> <span class="o">=</span> <span class="n">msg_shape</span>
        <span class="c1"># Link direction. Whether pointing toward a factor node. Of type bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_fn</span> <span class="o">=</span> <span class="n">to_fn</span>
        <span class="c1"># Threshold of KL-divergence metric to measure whether a candidate message is different from the existing one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span>
        <span class="c1"># Reserved field for additional attributes. Arbitrary type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="c1"># Pretty log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Override for pretty debugging and printing</span>
        <span class="n">fn_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">name</span>
        <span class="n">vn_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vn_name</span> <span class="o">+</span> <span class="s2">&quot; --&gt; &quot;</span> <span class="o">+</span> <span class="n">fn_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fn_name</span> <span class="o">+</span> <span class="s2">&quot; --&gt; &quot;</span> <span class="o">+</span> <span class="n">vn_name</span>

<div class="viewcode-block" id="LinkData.reset_shape"><a class="viewcode-back" href="../../../references/graphical/data-structures.html#pysigma.graphical._nodes.LinkData.reset_shape">[docs]</a>    <span class="k">def</span> <span class="nf">reset_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg_shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset shape for the Message</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        msg_shape : tuple of torch.Size</span>
<span class="sd">            The target message shape, in the format ``(batch_shape, param_shape, sample_shape, event_shape)``.  An empty</span>
<span class="sd">            shape ``torch.Size([])`` should be used as the default none shape.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This method will clear the memory buffer ``self.memory`` and set ``self.new`` to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg_shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">msg_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_shape</span> <span class="o">=</span> <span class="n">msg_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="LinkData.write"><a class="viewcode-back" href="../../../references/graphical/data-structures.html#pysigma.graphical._nodes.LinkData.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_msg</span><span class="p">,</span> <span class="n">check_diff</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes to the link message memory with the new message specified via `new_msg`. Once a new message is</span>
<span class="sd">        written, ``self.new`` will be set to ``True``.</span>

<span class="sd">        If `check_diff` is ``True``, will check if the new message is different from the existing one before</span>
<span class="sd">        replacing the existing with the new one.</span>

<span class="sd">        If `clone` is ``True``, then will first clone `new_msg` and store the cloned message in the memory buffer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            new_msg : Message</span>
<span class="sd">                The new message to be stored in this link-data.</span>
<span class="sd">            check_diff : bool, optional</span>
<span class="sd">                Whether to compare the difference between stored message against `new_msg` and decide whether to receive</span>
<span class="sd">                the new message and set ``self.new`` to ``True``.</span>
<span class="sd">            clone : bool, optional</span>
<span class="sd">                Whether to clone `new_msg` before storing it in the memory buffer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Messages will be deemed different in the following cases:</span>

<span class="sd">            1. If they are of different types,</span>
<span class="sd">            2. If new message has ``MessageType.Undefined`` type,</span>
<span class="sd">            3. If they both have parameters and the batch average L2 distance between the two parameter tensors</span>
<span class="sd">               is larger than ``epsilon``,</span>
<span class="sd">            4. If they both have particles and either their particle value tensors or their particle log sampling</span>
<span class="sd">               tensors are different.</span>
<span class="sd">            5. If they both have particles, and they possess the same particles value tensors and same sampling log</span>
<span class="sd">               density tensors, but the batch average cosine similarity distance between the two particle weight tensors</span>
<span class="sd">               is larger than ``epsilon``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            When `self` and `other` have type ``MessageType.Both``, the parameters will be chosen over the particles to</span>
<span class="sd">            compare message difference.</span>

<span class="sd">        .. note::</span>

<span class="sd">           If want to set a new message of a different message type than the current memory, make sure reset_shape()</span>
<span class="sd">           is first called so that shape check works for the new message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="c1"># Check new message shape</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg_shape</span> <span class="o">==</span> <span class="n">new_msg</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">same_size_as</span><span class="p">(</span><span class="n">new_msg</span><span class="p">)</span>

        <span class="c1"># Will replace the memory immediately if any one of the following conditions is met:</span>
        <span class="c1">#   - self.memory is None</span>
        <span class="c1">#   - check_diff is False</span>
        <span class="c1">#   - new message has different type</span>
        <span class="c1">#   - new message has Undefined type</span>
        <span class="c1">#   - messages have particles and new message has different particle values and/or sampling log densities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">check_diff</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">new_msg</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">type</span> <span class="ow">or</span> \
                <span class="n">new_msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Undefined</span> <span class="ow">or</span>\
                <span class="p">(</span><span class="n">MessageType</span><span class="o">.</span><span class="n">Particles</span> <span class="ow">in</span> <span class="n">new_msg</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">same_particles_as</span><span class="p">(</span><span class="n">new_msg</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">new_msg</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">if</span> <span class="n">clone</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">new_msg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

        <span class="c1"># Otherwise, check difference by KL-divergence</span>
        <span class="k">if</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="c1"># For Parameter message, compare batch average L2 distance</span>
            <span class="c1"># Parameter tensor has shape (batch_shape + param_shape), with param_shape of length 1</span>
            <span class="c1"># L2 distance is computed along param_shape dimension, i.e., the -1 dimension</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">diff_param</span><span class="p">(</span><span class="n">new_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For Particles message, compare batch average cosine similarity distance</span>
            <span class="c1"># Particle weights has shape (batch_shape + sample_shape)</span>
            <span class="c1"># cosine similarity distance is computed along sample_shape dimension. i.e., the 0 dimension</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">diff_weight</span><span class="p">(</span><span class="n">new_msg</span><span class="p">)</span>

        <span class="c1"># Compare distance value with epsilon</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">new_msg</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">if</span> <span class="n">clone</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">new_msg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LinkData.read"><a class="viewcode-back" href="../../../references/graphical/data-structures.html#pysigma.graphical._nodes.LinkData.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current content stored in memory. Set ``self.new`` to ``False`` to indicate this link message</span>
<span class="sd">        has been read in the current decision phase.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clone : bool</span>
<span class="sd">            Whether to return a cloned message of the memory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The current memory message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">if</span> <span class="n">clone</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span>
        <span class="k">return</span> <span class="n">msg</span></div></div>


<div class="viewcode-block" id="Node"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.Node">[docs]</a><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base class for all nodes in PySigma graphical architecture.</span>

<span class="sd">    Declares common attributes between `FactorNode` and `VariableNode`, for example a flag indicating whether this node</span>
<span class="sd">    has reach quiescence, i.e., whether no new message shall be sent via adjacent links in current cycle. During</span>
<span class="sd">    construction of the graph, its instance should be passed to `NetworkX` methods to instantiate a node.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the node.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the node.</span>
<span class="sd">    quiescence : bool</span>
<span class="sd">        Indicates whether this node has reached quiescence, and no further computation at this node is necessary at</span>
<span class="sd">        the current cycle. Will default to ``False`` at the start of the cycle.</span>
<span class="sd">    visited : bool</span>
<span class="sd">        Indicates whether this node has been visited at all, i.e., `compute()` method being called at the current cycle.</span>
<span class="sd">        Default to ``False`` at the start of the cycle.</span>
<span class="sd">    in_linkdata : list of LinkData</span>
<span class="sd">        List of incoming linkdata.</span>
<span class="sd">    out_linkdata : list of LinkData</span>
<span class="sd">        List of outgoing linkdata.</span>
<span class="sd">    log : dict</span>
<span class="sd">        Internal log</span>
<span class="sd">    pretty_log : dict</span>
<span class="sd">        Pretty log for beautiful front-end visualization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># Flag indicating whether quiescence reached in current cycle. If so, no sum-product local processing needed at</span>
        <span class="c1">#   this node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiescence</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Flag indicating whether this node has been visited (compute() method called) during a decision cycle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># List of LinkData of those link connecting to this node, incoming and outgoing ones respectively, from</span>
        <span class="c1">#   which we retrieve messages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Global logging info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Log info to display at the GUI</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># override to provide the node&#39;s name as its string representation</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<div class="viewcode-block" id="Node.check_quiesce"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.Node.check_quiesce">[docs]</a>    <span class="k">def</span> <span class="nf">check_quiesce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check ``new`` attribute of incoming linkdata to determine whether this node has reached quiescence.</span>

<span class="sd">        By default, a node is determined quiesced if and only if **all** incoming linkdata has no `new` message.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Certain nodes may desire a different behavior for checking quiescence. In that case, this method should be</span>
<span class="sd">            overridden.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if this node has reached quiescence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">quiesced</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">in_ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">new</span><span class="p">:</span>
                <span class="n">quiesced</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiescence</span> <span class="o">=</span> <span class="n">quiesced</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiescence</span></div>

<div class="viewcode-block" id="Node.add_link"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.Node.add_link">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adding linkdata connecting to this node.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Node.compute"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.Node.compute">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute method to be called to propagate messages during decision phase.</span>

<span class="sd">        Note that ``super()`` must be called within `compute()` method in any child class, because all abstract</span>
<span class="sd">        node-level statistics logging is taken care of herein.</span>

<span class="sd">        The default quiescence behavior for `compute()` is to return directly if `check_quiesce()` returns ``True``,</span>
<span class="sd">        without logging anything or performing any further computation. Note that such behavior may or may not be</span>
<span class="sd">        desired by child node class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return directly if quiesced</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_quiesce</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="c1"># TODO: Other general logging regarding node computation statistics to be added here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="FactorNode"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.FactorNode">[docs]</a><span class="k">class</span> <span class="nc">FactorNode</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factor node abstract base class.</span>

<span class="sd">    Guarantees that all incident nodes are variable nodes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this factor node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="FactorNode.add_link"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.FactorNode.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a linkdata connecting to a variable node</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linkdata : LinkData</span>
<span class="sd">            The incident linkdata to be registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">fn</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">linkdata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="VariableNode"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.VariableNode">[docs]</a><span class="k">class</span> <span class="nc">VariableNode</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Variable node abstract base class.</span>

<span class="sd">    Guarantees that all incident nodes are factor nodes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this variable node.</span>
<span class="sd">    rel_var_list : iterable of Variable</span>
<span class="sd">        Iterable of relational variables. Corresponds to the batch dimensions. Used to check ``b_shape`` attribute of</span>
<span class="sd">        incoming messages.</span>
<span class="sd">    param_var : Variable, optional</span>
<span class="sd">        The parameter variable. Corresponds to the parameter dimension. Used to check ``p_shape`` attribute of incoming</span>
<span class="sd">        messages.</span>
<span class="sd">    index_var_list : iterable of Variable, optional</span>
<span class="sd">        Iterable of indexing variables. Corresponds to the sample dimensions. Used to check ``s_shape`` attribute of</span>
<span class="sd">        incoming messages. Must specify if `ran_var_list` is specified.</span>
<span class="sd">    ran_var_list : iterable of Variable, optional</span>
<span class="sd">        Iterable of random variables. Corresponds to the event dimensions. Used to check ``e_shape`` attribute of</span>
<span class="sd">        incoming messages. Must specify if `index_var_list` is specified.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    rel_vars : tuple of Variable</span>
<span class="sd">        Tuple of relational variables, specified by `rel_var_list`.</span>
<span class="sd">    param_var : Variable</span>
<span class="sd">        Parameter variable, specified by `param_var`. Defaults to ``None`` if `param_var` is not specified.</span>
<span class="sd">    index_vars : tuple of Variable</span>
<span class="sd">        Tuple of indexing variables, specified by `index_var_list`. Defaults to ``None`` if `index_var_list` is not</span>
<span class="sd">        specified.</span>
<span class="sd">    ran_vars : tuple of Variable</span>
<span class="sd">        Tuple of random variables, specified by `ran_var_list`. Default sto ``None`` if `ran_var_list` is not specified.</span>
<span class="sd">    b_shape : torch.Size</span>
<span class="sd">        Batch dimension sizes. Inferred from `rel_vars`.</span>
<span class="sd">    p_shape : torch.Size</span>
<span class="sd">        Parameter dimension sizes. Inferred from `param_var`. Defaults to ``torch.Size([])``.</span>
<span class="sd">    s_shape : torch.Size</span>
<span class="sd">        Sample dimension sizes. Inferred from `index_vars`. Defaults to ``torch.Size([])``.</span>
<span class="sd">    e_shape : torch.Size</span>
<span class="sd">        Event dimension sizes. Inferred from `ran_vars`. Defaults to ``torch.Size([])``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rel_var_list</span><span class="p">,</span> <span class="n">param_var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_var_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ran_var_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VariableNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rel_var_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">metatype</span> <span class="ow">is</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Relational</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rel_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">param_var</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">param_var</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">param_var</span><span class="o">.</span><span class="n">metatype</span> <span class="o">==</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">index_var_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">index_var_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span>
             <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">metatype</span> <span class="o">==</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Indexing</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ran_var_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ran_var_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span>
             <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">metatype</span> <span class="o">==</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Random</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ran_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">index_var_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="p">(</span><span class="n">ran_var_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rel_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rel_var_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_var</span> <span class="o">=</span> <span class="n">param_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index_var_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">index_var_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ran_var_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">ran_var_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rel_vars</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">param_var</span><span class="o">.</span><span class="n">size</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_vars</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([])</span>

<div class="viewcode-block" id="VariableNode.add_link"><a class="viewcode-back" href="../../../references/graphical/abstract-base-nodes.html#pysigma.graphical._nodes.VariableNode.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register the LinkData connecting a factor node to this variable node.</span>

<span class="sd">        Checks that the preset message shape specified in `linkdata` agrees with the inferred message shape at this</span>
<span class="sd">        variable node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linkdata : LinkData</span>
<span class="sd">            The incident linkdata to be registered.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the linkdata to be added does not impose the same message shape restriction as this variable node does.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">msg_shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span><span class="p">),</span> \
            <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: The linkdata to be registered with the current node does not impose the same message shape &quot;</span> \
            <span class="s2">&quot;restriction as this node does. Current node&#39;s shape: (batch_shape, param_shape, sample_shape, &quot;</span> \
            <span class="s2">&quot;event_shape) = </span><span class="si">{}</span><span class="s2">. Found linkdata&#39;s shape: </span><span class="si">{}</span><span class="s2">&quot;</span>\
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span><span class="p">),</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">msg_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linkdata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span></div></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility structural nodes</span>
<span class="sd">        - DFN</span>
<span class="sd">        - DVN</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="DFN"><a class="viewcode-back" href="../../../references/graphical/other-structural-nodes.html#pysigma.graphical._nodes.DFN">[docs]</a><span class="k">class</span> <span class="nc">DFN</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default (Dummy) Factor Node.</span>

<span class="sd">    No special computation. Simply relays message to one or multiple incident variable nodes. Requires that incident</span>
<span class="sd">    variable nodes share the same variables. Only admits one incoming link but can connect with multiple outgoing links.</span>

<span class="sd">    Since all incident variable nodes should share the same variables, these variables will also be registered in the</span>
<span class="sd">    attributes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this node.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    rel_vars : tuple of Variable</span>
<span class="sd">        Tuple of relational variables.</span>
<span class="sd">    param_var : Variable</span>
<span class="sd">        Parameter variable.</span>
<span class="sd">    index_vars : tuple of Variable</span>
<span class="sd">        Tuple of indexing variables.</span>
<span class="sd">    ran_vars : tuple of Variable</span>
<span class="sd">        Tuple of random variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Default Factor Node&quot;</span>

        <span class="c1"># Since all incident nodes should have the same variable list, we can therefore log it here as an attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rel_vars</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_vars</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="DFN.add_link"><a class="viewcode-back" href="../../../references/graphical/other-structural-nodes.html#pysigma.graphical._nodes.DFN.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that all variable nodes on the other side of the linkdata share the same set of variables. Infer</span>
<span class="sd">        attribute values from the connected variable nodes&#39; variables.</span>

<span class="sd">        .. note::</span>

<span class="sd">           Only one incoming linkdata can be registered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linkdata : LinkData</span>
<span class="sd">            The linkdata to be registered.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If attempting to register more than one incoming linkdata.</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the variable node on the other side of the specified linkdata do not share the same set of variables as</span>
<span class="sd">            other variable nodes in those linkdata that are already registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="c1"># Make sure no more than on incoming link</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># Also make sure incident variable nodes&#39; var_list agree with each other</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rel_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_var</span> <span class="o">=</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">param_var</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_vars</span> <span class="o">=</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">=</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">rel_vars</span> <span class="o">==</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_vars</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_var</span> <span class="o">==</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">param_var</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_vars</span> <span class="o">==</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">index_vars</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_vars</span> <span class="o">==</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_vars</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span></div>

<div class="viewcode-block" id="DFN.compute"><a class="viewcode-back" href="../../../references/graphical/other-structural-nodes.html#pysigma.graphical._nodes.DFN.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Relay untempered message to downstream variable nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">in_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">out_ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">:</span>
            <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DVN"><a class="viewcode-back" href="../../../references/graphical/other-structural-nodes.html#pysigma.graphical._nodes.DVN">[docs]</a><span class="k">class</span> <span class="nc">DVN</span><span class="p">(</span><span class="n">VariableNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default (Dummy) Variable Node.</span>

<span class="sd">    No special computation. Simply relay message to one or multiple factor nodes. Only admits one incoming link but can</span>
<span class="sd">    connect with multiple outgoing links.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this variable node.</span>
<span class="sd">    rel_var_list : iterable of Variable</span>
<span class="sd">        Iterable of relational variables. Corresponds to the batch dimensions. Used to check ``b_shape`` attribute of</span>
<span class="sd">        incoming messages.</span>
<span class="sd">    param_var : Variable, optional</span>
<span class="sd">        The parameter variable. Corresponds to the parameter dimension. Used to check ``p_shape`` attribute of incoming</span>
<span class="sd">        messages.</span>
<span class="sd">    index_var_list : iterable of Variable, optional</span>
<span class="sd">        Iterable of indexing variables. Corresponds to the sample dimensions. Used to check ``s_shape`` attribute of</span>
<span class="sd">        incoming messages. Must specify if `ran_var_list` is specified.</span>
<span class="sd">    ran_var_list : iterable of Variable, optional</span>
<span class="sd">        Iterable of random variables. Corresponds to the event dimensions. Used to check ``e_shape`` attribute of</span>
<span class="sd">        incoming messages. Must specify if `index_var_list` is specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rel_var_list</span><span class="p">,</span> <span class="n">param_var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_var_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ran_var_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DVN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rel_var_list</span><span class="p">,</span> <span class="n">param_var</span><span class="p">,</span> <span class="n">index_var_list</span><span class="p">,</span> <span class="n">ran_var_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Default Variable Node&quot;</span>

<div class="viewcode-block" id="DVN.add_link"><a class="viewcode-back" href="../../../references/graphical/other-structural-nodes.html#pysigma.graphical._nodes.DVN.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Guarantees that no more than on incoming link is registered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linkdata : LinkData</span>
<span class="sd">            The linkdata to be registered.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If attempting to register more than one incoming linkdata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="c1"># Make sure no more than on incoming link</span>
        <span class="k">assert</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DVN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span></div>

<div class="viewcode-block" id="DVN.compute"><a class="viewcode-back" href="../../../references/graphical/other-structural-nodes.html#pysigma.graphical._nodes.DVN.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Relay untempered message to downstream factor nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DVN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="n">in_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">out_ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">:</span>
            <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nodes relating to Predicate subgraph structures</span>
<span class="sd">        - WMVN</span>
<span class="sd">        - LTMFN</span>
<span class="sd">        - PBFN</span>
<span class="sd">        - WMFN</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="WMVN"><a class="viewcode-back" href="../../../references/graphical/predicate-nodes.html#pysigma.graphical._nodes.WMVN">[docs]</a><span class="k">class</span> <span class="nc">WMVN</span><span class="p">(</span><span class="n">VariableNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Working Memory Variable Node.</span>

<span class="sd">    Gate node connecting predicate structure to conditionals.</span>

<span class="sd">    A KnowledgeServer instance associated with the belonging Predicate is required because occasionally log prob of</span>
<span class="sd">    particles needs to be queried.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this variable node.</span>
<span class="sd">    ks : KnowledgeServer</span>
<span class="sd">        The KnowledgeServer instance associated with the belonging Predicate.</span>
<span class="sd">    rel_var_list : iterable of Variable</span>
<span class="sd">        Iterable of relational variables. Corresponds to the batch dimensions. Used to check ``b_shape`` attribute of</span>
<span class="sd">        incoming messages.</span>
<span class="sd">    param_var : Variable, optional</span>
<span class="sd">        The parameter variable. Corresponds to the parameter dimension. Used to check ``p_shape`` attribute of incoming</span>
<span class="sd">        messages.</span>
<span class="sd">    index_var_list : iterable of Variable, optional</span>
<span class="sd">        Iterable of indexing variables. Corresponds to the sample dimensions. Used to check ``s_shape`` attribute of</span>
<span class="sd">        incoming messages. Must specify if `ran_var_list` is specified.</span>
<span class="sd">    ran_var_list : iterable of Variable, optional</span>
<span class="sd">        Iterable of random variables. Corresponds to the event dimensions. Used to check ``e_shape`` attribute of</span>
<span class="sd">        incoming messages. Must specify if `index_var_list` is specified.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ks : KnowledgeServer</span>
<span class="sd">        The KnowledgeServer instance associated with the belonging Predicate.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">rel_var_list</span><span class="p">,</span> <span class="n">param_var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_var_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ran_var_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KnowledgeServer</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WMVN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rel_var_list</span><span class="p">,</span> <span class="n">param_var</span><span class="p">,</span> <span class="n">index_var_list</span><span class="p">,</span> <span class="n">ran_var_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Working Memory Variable Node&quot;</span>

        <span class="c1"># Distribution class the Predicate self belongs to is assuming</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ks</span> <span class="o">=</span> <span class="n">ks</span>
        <span class="c1"># Cache for temporarily saving computation result for combination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="WMVN.compute"><a class="viewcode-back" href="../../../references/graphical/predicate-nodes.html#pysigma.graphical._nodes.WMVN.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine incoming message to this Predicate subgraph.</span>

<span class="sd">        Will attempt to combine incoming messages if there are multiple incoming links, subsuming the functionality of</span>
<span class="sd">        FAN node in Lisp Sigma. Combination can be carried out if messages are all Parameter type, or if there exist</span>
<span class="sd">        Particles type messages but all of them are homogeneous (sharing the same particle values as well as sampling</span>
<span class="sd">        log densities).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the ``MessageType.Particles`` type messages in the incoming links do not share the same particles</span>
<span class="sd">            (including particle value tensors and/or particle log sampling density tensors)</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">            If there is only one incoming link, but this link is connected to a factor node that is also connected from</span>
<span class="sd">            this WMVN via an outgoing link. This means, per Sum-Product exclusion principle, that this outgoing link</span>
<span class="sd">            will also be neglected during compute() and no new message will ever be propagated via this link.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Following combination procedure is carried out to conform to the standard of all inference methods</span>

<span class="sd">        1. If all messages are of type ``MessageType.Parameter`` or ``MessageType.Both``, i.e., all containing parameters,</span>
<span class="sd">           then the default combination behavior is to take the sum over all the parameters. The assumption made here is</span>
<span class="sd">           that these parameters reside in some parameter vector space, and that the addition operation is well-defined.</span>
<span class="sd">           See :ref:`Message class notes on arithmetic structures&lt;message-arithmetic-structures-notes&gt;` for more</span>
<span class="sd">           details.</span>

<span class="sd">           The parameter representation of distributions is given a higher priority than the particle representation.</span>
<span class="sd">           Therefore, in this case, the particles in ``MessageType.Both`` type message would be discarded by calling</span>
<span class="sd">           `reduce_type()` method on the message.</span>

<span class="sd">        2. If there exists ``MessageType.Particles`` type incoming message, meaning that it contains only particles:</span>

<span class="sd">           a. Find all messages of such type, and ensure that their particles are homogeneous.</span>
<span class="sd">           b. If there are other ``MessageType.Parameter`` or ``MessageType.Both`` type messages, then the particles in</span>
<span class="sd">              above messages will be borrowed as the surrogate particles, and be importance weighted w.r.t. the distribution</span>
<span class="sd">              parameter to form a ``MessageType.Particles`` type message.</span>
<span class="sd">           c. As all message now possess particles as representation for the distributions, the combination will be taken</span>
<span class="sd">              by taking the element-wise multiplication of the weight tensors with normalization. See</span>
<span class="sd">              :ref:`Message class notes on arithmetic structures&lt;message-arithmetic-structures-notes&gt;` for more details.</span>

<span class="sd">        When combining messages, will exclude message from the link to which the combined message is to send to (if</span>
<span class="sd">        such a bidirected link exists). This implements the Sum-Product algorithm&#39;s variable node semantics, if</span>
<span class="sd">        this WMVN is served as both WMVN_IN and WMVN_OUT, i.e., if the predicate is of memory-less vector type.</span>

<span class="sd">        Optimization is implemented by caching the combination result for each outgoing link. If two outgoing links</span>
<span class="sd">        share the same set of incoming links that provide the messages, previously computed result will be reused</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WMVN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="c1"># Relay message if only one incoming link</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">in_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">out_ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">:</span>
                <span class="c1"># Throw a warning if the outgoing link is connected to the same factor node that the only incoming</span>
                <span class="c1">#   link is connected to, since in such case no message would be sent to that factor node</span>
                <span class="k">if</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">fn</span> <span class="ow">is</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">fn</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WMVN &#39;</span><span class="si">{}</span><span class="s2">&#39; is connected to factor node &#39;</span><span class="si">{}</span><span class="s2">&#39;, while its only incoming link is also &quot;</span>
                                  <span class="s2">&quot;connected from the same factor node. In this case no message would be sent out to &quot;</span>
                                  <span class="s2">&quot;the factor node. Please check if the model is properly defined&quot;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Otherwise, combine messages</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">out_ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">:</span>
                <span class="c1"># The tuple of all incoming linkdata that are not connected to the factor node the selected outgoing</span>
                <span class="c1">#   linkdata is connected to.</span>
                <span class="c1"># Use tuple here because tuple is hashable and we will use it as keys to cache dictionary</span>
                <span class="n">in_lds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">in_ld</span> <span class="k">for</span> <span class="n">in_ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span> <span class="k">if</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>

                <span class="c1"># Check if there&#39;s cached data. If yes, use cached result</span>
                <span class="k">if</span> <span class="n">in_lds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">out_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">in_lds</span><span class="p">]</span>
                <span class="c1"># Otherwise, compute combined message</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">in_msgs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="k">for</span> <span class="n">in_ld</span> <span class="ow">in</span> <span class="n">in_lds</span><span class="p">)</span>
                    <span class="c1"># 1. Find if there&#39;s any Particles message</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Particles</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">in_msgs</span><span class="p">):</span>
                        <span class="c1"># 1.a. Ensure all particle lists are homogeneous</span>
                        <span class="n">particle_msgs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">msg</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">in_msgs</span> <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Particles</span><span class="p">)</span>
                        <span class="n">particle_lds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ld</span> <span class="k">for</span> <span class="n">ld</span> <span class="ow">in</span> <span class="n">in_lds</span> <span class="k">if</span> <span class="n">ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Particles</span><span class="p">)</span>
                        <span class="n">tmp_msg</span><span class="p">,</span> <span class="n">tmp_ld</span> <span class="o">=</span> <span class="n">particle_msgs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">particle_lds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmp_msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">msg</span><span class="p">,</span> <span class="n">in_ld</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">particle_msgs</span><span class="p">,</span> <span class="n">particle_lds</span><span class="p">):</span>
                            <span class="k">assert</span> <span class="n">tmp_msg</span><span class="o">.</span><span class="n">same_particles_as</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> \
                                <span class="s2">&quot;At WMVN &#39;</span><span class="si">{}</span><span class="s2">&#39;: When attempting to combine incoming messages, found that incoming &quot;</span> \
                                <span class="s2">&quot;Particle message&#39;s particles (particle value tensors and/or particle log sampling &quot;</span> \
                                <span class="s2">&quot;density tensors) from  linkdata &#39;</span><span class="si">{}</span><span class="s2">&#39; does not agree with that of incoming Particle &quot;</span> \
                                <span class="s2">&quot;message from linkdata &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span> \
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">tmp_ld</span><span class="p">)</span>

                        <span class="c1"># 1.b Find message that contains parameter. If they exist, use the particles from the above</span>
                        <span class="c1"># messages as surrogate particle list and query its log prob w.r.t. the parameter.</span>
                        <span class="n">param_msgs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">msg</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">in_msgs</span> <span class="k">if</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Parameter</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                        <span class="n">particles</span> <span class="o">=</span> <span class="n">tmp_msg</span><span class="o">.</span><span class="n">particles</span>

                        <span class="c1"># 2.b Compute particle weights w.r.t. distributions induced by the Parameter type messages</span>
                        <span class="n">candidate_msgs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">particle_msgs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">param_msg</span> <span class="ow">in</span> <span class="n">param_msgs</span><span class="p">:</span>
                            <span class="n">target_log_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="o">.</span><span class="n">surrogate_log_prob</span><span class="p">(</span><span class="n">param_msg</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span> <span class="n">particles</span><span class="p">)</span>
                            <span class="n">surrogate_msg</span> <span class="o">=</span> <span class="n">tmp_msg</span><span class="o">.</span><span class="n">event_reweight</span><span class="p">(</span><span class="n">target_log_prob</span><span class="p">)</span>
                            <span class="n">candidate_msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surrogate_msg</span><span class="p">)</span>

                        <span class="c1"># Combine messages</span>
                        <span class="n">out_msg</span> <span class="o">=</span> <span class="n">candidate_msgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">candidate_msgs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">out_msg</span> <span class="o">+=</span> <span class="n">msg</span>

                    <span class="c1"># 2. Otherwise all messages are Parameter type</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out_msg</span> <span class="o">=</span> <span class="n">in_msgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">in_msgs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">out_msg</span> <span class="o">+=</span> <span class="n">msg</span>

                <span class="c1"># Cache result</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">in_lds</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_msg</span>
                <span class="c1"># Send message</span>
                <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_msg</span><span class="p">)</span>

            <span class="c1"># Clear cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span></div></div>


<div class="viewcode-block" id="LTMFN"><a class="viewcode-back" href="../../../references/graphical/predicate-nodes.html#pysigma.graphical._nodes.LTMFN">[docs]</a><span class="k">class</span> <span class="nc">LTMFN</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Long-Term Memory Factor Node.</span>

<span class="sd">    Memorizes and updates the predicate&#39;s knowledge across decision cycles. Hosts and maintains the associated</span>
<span class="sd">    KnowledgeServer instance to provide service to downstream nodes.</span>

<span class="sd">    Admits one incoming link from `WMVN_IN` that contains combined action message toward this predicate by the end of</span>
<span class="sd">    the decision cycle, as well as arbitrary number of incoming links from parameter feeds and/or `WMFN` that contains</span>
<span class="sd">    parameter messages. Special attribute therefore needs to be declared in the linkdata&#39;s attribute dictionary to</span>
<span class="sd">    distinguish which one sends &quot;event&quot; message from `WMVN_IN` and which ones send &quot;param&quot; messages from parameter</span>
<span class="sd">    feeds.</span>

<span class="sd">    If there are multiple incoming &quot;param&quot; labeled links, then combination will be carried out by taking summation over</span>
<span class="sd">    the parameters. See</span>
<span class="sd">    :ref:`Message class notes on arithmetic structures&lt;message-arithmetic-structures-notes&gt;`</span>
<span class="sd">    for more details.</span>

<span class="sd">    Particles should be drawn during modification phase of each cognitive cycle by calling `init_msg()` method,</span>
<span class="sd">    which internally calls the corresponding method of the KnowledgeServer instance to perform the Gibbs sampling</span>
<span class="sd">    procedure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of this node.</span>
<span class="sd">    ks : KnowledgeServer</span>
<span class="sd">        The KnowledgeServer instance associated with the predicate.</span>
<span class="sd">    rel_var_list : iterable of Variable</span>
<span class="sd">        Iterable of relational variables, corresponding to the predicate&#39;s relational arguments.</span>
<span class="sd">    param_var : Variable</span>
<span class="sd">        The parameter variable.</span>
<span class="sd">    index_var_list : iterable of Variable</span>
<span class="sd">        Iterable of indexing variables.</span>
<span class="sd">    ran_var_list : iterable of Variable</span>
<span class="sd">        Iterable of random variables, corresponding to the predicate&#39;s random arguments.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ks</span>
<span class="sd">    rel_var_list</span>
<span class="sd">    param_var</span>
<span class="sd">    index_var_list</span>
<span class="sd">    ran_var_list</span>
<span class="sd">    b_shape : torch.Size</span>
<span class="sd">        The batch shape.</span>
<span class="sd">    p_shape : torch.Size</span>
<span class="sd">        The parameter shape (size).</span>
<span class="sd">    s_shape : torch.Size</span>
<span class="sd">        The sample shape.</span>
<span class="sd">    e_shape : torch.Size</span>
<span class="sd">        The event shape.</span>
<span class="sd">    msg_cache : Message</span>
<span class="sd">        The message cache. Set during modification phase, and sent during decision phase of the next cognitive cycle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">rel_var_list</span><span class="p">,</span> <span class="n">param_var</span><span class="p">,</span> <span class="n">index_var_list</span><span class="p">,</span> <span class="n">ran_var_list</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LTMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Long-Term Memory Factor Node&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">KnowledgeServer</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rel_var_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">metatype</span> <span class="ow">is</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Relational</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rel_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param_var</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">param_var</span><span class="o">.</span><span class="n">metatype</span> <span class="ow">is</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Parameter</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_var_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">metatype</span> <span class="ow">is</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Indexing</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ran_var_list</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">metatype</span> <span class="ow">is</span> <span class="n">VariableMetatype</span><span class="o">.</span><span class="n">Random</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ran_var_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ks</span> <span class="o">=</span> <span class="n">ks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rel_var_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rel_var_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_var</span> <span class="o">=</span> <span class="n">param_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_var_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index_var_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ran_var_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ran_var_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rel_var_list</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">param_var</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_var_list</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ran_var_list</span><span class="p">])</span>

        <span class="c1"># Message cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_cache</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="LTMFN.add_link"><a class="viewcode-back" href="../../../references/graphical/predicate-nodes.html#pysigma.graphical._nodes.LTMFN.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Only admits one incoming and one outgoing event message link, the former should be connected from `WMVN_IN`</span>
<span class="sd">        and the later from `WMVN_OUT` (can be the same WMVN instance). However can admit multiple incoming</span>
<span class="sd">        parameter message link.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linkdata : LinkData</span>
<span class="sd">            The linkdata to be registered. The ``&#39;type&#39;`` key-ed attribute must present in the linkdata&#39;s attribute</span>
<span class="sd">            dict.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If the new linkdata does not have identical batch shape and param shape.</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If attempting to register more than one outgoing link.</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If ``&#39;type&#39;`` key does not exist in the linkdata&#39;s attribute dict, or if the associated value is neither</span>
<span class="sd">            ``&#39;event&#39;`` nor ``&#39;param&#39;``.</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If attempting to register more than one `event` incoming link.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the linkdata has correct batch shape and param shape.</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">msg_shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_shape</span><span class="p">)</span>

        <span class="c1"># Only admit one outgoing link and that must be WMVN. Check dimensions to be compatible with event message</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="p">,</span> <span class="n">WMVN</span><span class="p">),</span> \
                <span class="s2">&quot;Attempting to register more than one outgoing linkdata.&quot;</span>
        <span class="c1"># Can admit multiple incoming links. Check that link has special attribute declared.</span>
        <span class="c1">#   Check dimension for parameter link and event link respectively</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s1">&#39;type&#39;</span> <span class="ow">in</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> \
                <span class="s2">&quot;At</span><span class="si">{}</span><span class="s2">: Incoming link to a LTMFN must specify &#39;type&#39; special attribute&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;event&#39;</span><span class="p">,</span> <span class="s1">&#39;param&#39;</span><span class="p">],</span> \
                <span class="s2">&quot;At</span><span class="si">{}</span><span class="s2">: Incoming link to a LTMFN must have &#39;type&#39; special attribute with value &#39;event&#39; or &#39;param&#39;&quot;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;event&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ld</span> <span class="k">for</span> <span class="n">ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span> <span class="k">if</span> <span class="n">ld</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;event&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>\
                    <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: Attempting to register more than one incoming event type linkdata&quot;</span>
        
        <span class="nb">super</span><span class="p">(</span><span class="n">LTMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span></div>

<div class="viewcode-block" id="LTMFN.init_msg"><a class="viewcode-back" href="../../../references/graphical/predicate-nodes.html#pysigma.graphical._nodes.LTMFN.init_msg">[docs]</a>    <span class="k">def</span> <span class="nf">init_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws particles and instantiate new message for next cognitive cycle.</span>

<span class="sd">        This method should be called during the modification phase. Parameter will be gathered from incoming `param`</span>
<span class="sd">        linkdata, and in the case of multiple incoming `param` linkdata the parameter tensors gathered will be combined.</span>
<span class="sd">        A new list of particles will then be drawn in the cognitive format by querying the given KnowledgeServer.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If no `param` type incoming linkdata is found.</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If messages read from incoming linkdata do not all contain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Obtain parameters from incoming &#39;param&#39; link.</span>
        <span class="n">param_lds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ld</span> <span class="k">for</span> <span class="n">ld</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span> <span class="k">if</span> <span class="n">ld</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;param&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_lds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: Attempting to gather parameters, but no incoming param type linkdata found.&quot;</span>

        <span class="n">param_msgs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="k">for</span> <span class="n">ld</span> <span class="ow">in</span> <span class="n">param_lds</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">MessageType</span><span class="o">.</span><span class="n">Parameter</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">param_msgs</span><span class="p">),</span> \
            <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: Expect all messages from incoming param type linkdata to contain parameters, but instead found &quot;</span> \
            <span class="s2">&quot;message types: </span><span class="si">{}</span><span class="s2"> from linkdata </span><span class="si">{}</span><span class="s2">.&quot;</span>\
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">param_msgs</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ld</span><span class="p">)</span> <span class="k">for</span> <span class="n">ld</span> <span class="ow">in</span> <span class="n">param_lds</span><span class="p">))</span>

        <span class="c1"># Combine parameter messages and extract the parameter tensor</span>
        <span class="n">param</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">param_msgs</span><span class="p">)</span><span class="o">.</span><span class="n">parameter</span>
        <span class="c1"># Query KnowledgeServer to extract components of a particle list.</span>
        <span class="n">particles</span><span class="p">,</span> <span class="n">log_densities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="o">.</span><span class="n">draw_particles</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span><span class="p">,</span> <span class="n">update_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">log_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="o">.</span><span class="n">surrogate_log_prob</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

        <span class="c1"># Instantiate a temporary message with uniform weight and use Message method to obtain re-weighted message</span>
        <span class="n">tmp_msg</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span><span class="n">MessageType</span><span class="o">.</span><span class="n">Both</span><span class="p">,</span>
                          <span class="n">batch_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span><span class="p">,</span> <span class="n">param_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_shape</span><span class="p">,</span>
                          <span class="n">sample_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span><span class="p">,</span> <span class="n">event_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span><span class="p">,</span>
                          <span class="n">parameter</span><span class="o">=</span><span class="n">param</span><span class="p">,</span> <span class="n">particles</span><span class="o">=</span><span class="n">particles</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">log_densities</span><span class="o">=</span><span class="n">log_densities</span><span class="p">,</span>
                          <span class="n">dist_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ks</span><span class="o">.</span><span class="n">dist_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_cache</span> <span class="o">=</span> <span class="n">tmp_msg</span><span class="o">.</span><span class="n">event_reweight</span><span class="p">(</span><span class="n">log_prob</span><span class="p">)</span></div>

<div class="viewcode-block" id="LTMFN.compute"><a class="viewcode-back" href="../../../references/graphical/predicate-nodes.html#pysigma.graphical._nodes.LTMFN.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Send message in ``self.msg_cache`` to the connected `WMVN_OUT` node.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If there are no connected outgoing linkdata.</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If ``self.msg_cache`` is None. This means `init_msg()` were not called prior to the current decision phase</span>
<span class="sd">            which calls this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LTMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: No cached message at this LTMFN node to be send outward. init_msg() should first be called prior &quot;</span> \
            <span class="s2">&quot;to calling this method.&quot;</span>
        <span class="n">out_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_cache</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">PBFN</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perception Buffer Factor Node.</span>

<span class="sd">        Receive perception / observation / evidence as particle list and send to WMVN.</span>
<span class="sd">            Shape is assumed correct, so shape check as well as value check should be performed at the Cognitive level</span>
<span class="sd">            in the caller of set_perception()</span>

<span class="sd">        Currently do not support incoming link. Can only have one outgoing link connecting to a WMVN.</span>

<span class="sd">        Perception is buffered, and will be latched to next cycle if no new observation is specified.</span>

<span class="sd">        Overwrite check_quiesce() so that quiescence is determined by self.visited, i.e., whether compute() has been</span>
<span class="sd">            carried out</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PBFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Perceptual Buffer Function Node&quot;</span>

        <span class="c1"># Perception buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">set_perception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">num_obs</span><span class="p">,</span> <span class="n">b_shape</span><span class="p">,</span> <span class="n">e_shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Update the perception buffer with new observation tensor. Should be called by the cognitive architecture</span>
<span class="sd">            Need to specify weights corresponding to the observation particles. Sampling log density on the other hand</span>
<span class="sd">                will be set to 0 in the outgoing Particle message.</span>

<span class="sd">            :param obs:     Observations. torch.Tensor. shape ([num_obs] + b_shape + e_shape)</span>
<span class="sd">            :param weights: Weights. torch.Tensor or int. shape ([num_obs] + b_shape) if tensor, otherwise an int of 1</span>
<span class="sd">                                to indicate uniform weights</span>
<span class="sd">            :param num_obs: torch.Size</span>
<span class="sd">            :param b_shape: torch.Size</span>
<span class="sd">            :param e_shape: torch.Size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_obs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b_shape</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_shape</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">obs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">num_obs</span><span class="p">])</span> <span class="o">+</span> <span class="n">b_shape</span> <span class="o">+</span> <span class="n">e_shape</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">num_obs</span><span class="p">])</span> <span class="o">+</span> <span class="n">b_shape</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">weights</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">obs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">num_obs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">=</span> <span class="n">b_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span> <span class="o">=</span> <span class="n">e_shape</span>

    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="c1"># Ensure that no incoming link and only one outgoing link connecting to a WMVN</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="o">.</span><span class="n">vn</span><span class="p">,</span> <span class="n">WMVN</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PBFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PBFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="c1"># If no perception has been set in the buffer, then do not send</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Otherwise, send either way. Sampling log density set to uniform 0</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">out_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out_msg</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span><span class="n">MessageType</span><span class="o">.</span><span class="n">Particles</span><span class="p">,</span>
                          <span class="n">sample_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">s_shape</span><span class="p">,</span> <span class="n">batch_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b_shape</span><span class="p">,</span> <span class="n">event_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">e_shape</span><span class="p">,</span>
                          <span class="n">particles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">log_density</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_msg</span><span class="p">)</span>

    <span class="c1"># Override check_quiesce() so that quiescence is equivalent to visited</span>
    <span class="k">def</span> <span class="nf">check_quiesce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiescence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiescence</span>


<span class="k">class</span> <span class="nc">WMFN</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Working Memory Factor Node.</span>

<span class="sd">        Effectively a buffer node that contains a memory buffer, whose content will be sent</span>
<span class="sd">            as outgoing message only until the next decision cycle. During modification phase, the memory buffer content</span>
<span class="sd">            can either be replaced entirely by, or taken a weighted sum with incoming message.</span>

<span class="sd">        WMFN can buffer either parameters memory or event memory. However, each of them entails different handling.</span>
<span class="sd">            Therefore, one must specify a type to be either &#39;param&#39; or &#39;event&#39; during initialization.</span>

<span class="sd">        Can specify a decay rate. The new memory is then derived via</span>
<span class="sd">                old_content * (1 - decay_rate) + new_content</span>
<span class="sd">            therefore if decay_rate is 1 (default value), the old content will be completely forgotten.</span>

<span class="sd">        The weighted sum procedure is viewed as a linear combination process in the message space. The linear operator</span>
<span class="sd">            (addition, scalar multiplication) definitions are different depending on the content type. Please see</span>
<span class="sd">            Message class documentation for more info.</span>

<span class="sd">        Note that the incoming message will always be cloned before performing weighted sum update. This is to prevent</span>
<span class="sd">            any parts of the memory message from in-place change by some parts elsewhere in the graph.</span>

<span class="sd">        Can admit only one incoming and one outgoing links.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">content_type</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            :param content_type: one of &#39;param&#39; or &#39;event&#39;</span>
<span class="sd">            :param decay_rate:   The decay rate at which the old memory vanished. Within range [0, 1]</span>
<span class="sd">                                 Default to 1, i.e., entirely forgetting old memory and replace with new content</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Working Memory Function Node&quot;</span>

        <span class="k">assert</span> <span class="n">content_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">,</span> <span class="s1">&#39;event&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decay_rate</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">decay_rate</span> <span class="o">&lt;=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">content_type</span> <span class="o">=</span> <span class="n">content_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_rate</span> <span class="o">=</span> <span class="n">decay_rate</span>
        <span class="c1"># memory buffer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Override so that only allow one incoming link and one outgoing link</span>
    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">WMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Update the content in memory using message from incoming link.</span>
<span class="sd">            Should only be called during modification phase</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">in_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Clone incoming message</span>
        <span class="n">new_msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_msg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span>
                                       <span class="n">new_msg</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>

        <span class="c1"># If memory is None or decay_rate is 1, directly replace memory buffer content</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay_rate</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">new_msg</span>
        <span class="c1"># Otherwise, perform weighted sum update</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">new_msg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay_rate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Sends memory content toward outgoing link (if memory is not None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">)</span>

    <span class="c1"># Overrides so that quiescence for WMFN is equivalent to visited</span>
    <span class="k">def</span> <span class="nf">check_quiesce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiescence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiescence</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nodes relating to Conditional Alpha subgraph structures</span>
<span class="sd">        - AlphaFactorNode: RMFN, ESFN</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">AlphaFactorNode</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract base class for any factor node belonging to a alpha subgraph</span>

<span class="sd">        The commonality of all alpha subgraph factor nodes is that they all only admit up to two paris of incoming and</span>
<span class="sd">            outgoing link. Additionally, links must declare a special attribute &#39;direction&#39; with value &#39;inward&#39; or</span>
<span class="sd">            &#39;outward&#39; to indicate whether it is pointing toward the conditional gamma factor node or not.</span>

<span class="sd">        Such link check is implemented in add_link() to be inherited by concrete alpha factor node class. Also</span>
<span class="sd">            implemented in this method is the registration of labeled pairs of linkdata in self.labeled_ld_pair</span>

<span class="sd">        compute() is implemented so that it execute inward_compute() and/or outward_compute() based on the presence of</span>
<span class="sd">            linkdata pairs.</span>

<span class="sd">        inward_compute() and outward_compute() are now abstract methods that must be implemented by child classes, but</span>
<span class="sd">            compute() should not be override.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Pairs of incoming and outgoing linkdata labeled with their directionality w.r.t. the alpha structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s1">&#39;direction&#39;</span> <span class="ow">in</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span> <span class="ow">and</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;inward&#39;</span><span class="p">,</span> <span class="s1">&#39;outward&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
            
        <span class="nb">super</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>

        <span class="c1"># If the other ld of this ld pair has not been added, then temporarily register this ld instance directly</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">linkdata</span>
        <span class="c1"># Otherwise, take out the other ld of this ld pair from the dict and replace entry with a tuple</span>
        <span class="c1">#   Make sure that incoming ld is the first element of the tuple and outgoing ld the second element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_ld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">other_ld</span><span class="p">)</span> <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span> <span class="k">else</span> <span class="p">(</span><span class="n">other_ld</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_linkdata</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_linkdata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Carry out directional computation based on presence of link in self.labeled_ld_pair</span>
        <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_pair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;inward&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inward_compute</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outward_compute</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Inward message computation. To be implemented by child class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Outward message computation. To be implemented by child class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">RMFN</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Relation Variable Mapping Node</span>

<span class="sd">        Convert between predicate arguments and pattern variables. Apply relational variable&#39;s VariableMap (if declared)</span>
<span class="sd">            by selecting and placing entries among the message batch dimensions. This node can thus carry out</span>
<span class="sd">            inner-pattern relational variable matching by itself.</span>

<span class="sd">        This node is a component of the alpha conditionial subgraph, so admits up to two pairs of incoming and outgoing</span>
<span class="sd">            links. Link must declare special attribute &#39;direction&#39; with value &#39;inward&#39; or &#39;outward&#39; to indicate whether</span>
<span class="sd">            it is pointing toward the conditional gamma factor node or not.</span>

<span class="sd">        For inward direction, inner-pattern relational variable matching is handled by selecting entries on the</span>
<span class="sd">            diagonals from the incoming message. For outward direction, this is handled by placing incoming message onto</span>
<span class="sd">            the diagonals of a larger message tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">arg2var</span><span class="p">,</span> <span class="n">var2arg</span><span class="p">,</span> <span class="n">arg2var_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Necessary data structure:</span>

<span class="sd">            :param  arg2var:    dictionary mapping predicate argument Variable instance to pattern variable Variable</span>
<span class="sd">                                    instance</span>
<span class="sd">            :param  var2arg:    dictionary mapping pattern variable Variable instance to LIST of predicate argument</span>
<span class="sd">                                    Variable instance(s)</span>
<span class="sd">            :param  arg2var_map:    dictionary mapping predicate argument Variable instance to VariableMap instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RMFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Relation Variable Mapping Node&quot;</span>
        
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg2var</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">arg2var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> \
               <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arg2var</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var2arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var2arg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> \
               <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">var2arg</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg2var_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">arg2var_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> \
               <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">VariableMap</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arg2var_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span> <span class="o">=</span> <span class="n">arg2var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span> <span class="o">=</span> <span class="n">var2arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map</span> <span class="o">=</span> <span class="n">arg2var_map</span>

        <span class="c1"># Obtain mapping dictionary and inverse mapping dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="n">var_map</span><span class="o">.</span><span class="n">get_map</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_inv_tuple</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="n">var_map</span><span class="o">.</span><span class="n">get_inverse_map</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Inward computation. Convert predicate relational arguments to pattern relational variables. Apply mappings</span>
<span class="sd">                to relational variable&#39;s values, if specified.</span>

<span class="sd">            For inward direction, we are assuming this is used in condition or condact patterns. Accordingly, the</span>
<span class="sd">                inverse mapping should be used to map predicate arguments to pattern variables.</span>

<span class="sd">            Will check anyway if domain and image of the inverse map agree with the size range of the predicate argument</span>
<span class="sd">                and pattern variable respectively. However to be user friendly this should be checked beforehand by</span>
<span class="sd">                compiler.</span>

<span class="sd">            Note that domain should be a subset of predicate argument size range, but image should be exactly equal to</span>
<span class="sd">                the pattern variable size range</span>

<span class="sd">            The computations to be carried out can be summarized in three steps: map/broaden, diagonalize, &amp; permute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_var_list</span><span class="p">,</span> <span class="n">out_rel_var_list</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span>

        <span class="c1"># Check that given data structures agree with variable lists of the incident variable node</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">)</span>
        <span class="c1"># Check that mapping&#39;s domain and image agree with variables&#39; sizes</span>
        <span class="c1">#   Note that for inward computation we are using the inverse map</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map_tuple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_inv_tuple</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pat_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">var_map_tuple</span>
            <span class="k">assert</span> <span class="n">domain</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
            <span class="k">assert</span> <span class="n">image</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

        <span class="c1"># 1. First, translate predicate arguments to pattern variables. This step involves broadening the variable</span>
        <span class="c1">#       dimension if predicate argument size is smaller than pattern variable size, or map predicate argument</span>
        <span class="c1">#       values to pattern variable values if a VariableMap is specified for the given predicate argument.</span>
        <span class="c1">#    For the mapping we should use original forward mapping, because we are selecting &quot;image&quot; to place in</span>
        <span class="c1">#       &quot;domain&quot;, in the order mandated by domain.</span>
        <span class="c1">#    Note that we have guaranteed that forward mapping&#39;s domain is equal to pattern variable&#39;s size range</span>
        <span class="c1">#    A running list of variables is maintained to keep track of variable dimensions</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">):</span>
            <span class="n">pat_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
            <span class="c1"># Apply map if VariableMap is specified</span>
            <span class="k">if</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">map_dict</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">map_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_index_select</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="c1"># Broaden the variable dimension size if currently it is smaller than the pattern variable&#39;s size</span>
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_broaden</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="c1"># Change predicate argument to pattern variable Variable instance</span>
            <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_var</span>

        <span class="c1"># 2. The step above guarantees that for any dimensions that share the same pattern variable, their axis values</span>
        <span class="c1">#       are semantically identical to the pattern variable&#39;s value.</span>
        <span class="c1">#    Now we should collapse the dimensions that share the same pattern variable, by selecting the diagonal</span>
        <span class="c1">#       entries across these dimensions.</span>
        <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">mapped_var_list</span><span class="p">:</span>
            <span class="c1"># Current position of pt_var in the moving mapped_var_list. Using enumerate() iterator will not return</span>
            <span class="c1">#   index of value w.r.t. a moving list</span>
            <span class="n">dim1</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
            <span class="c1"># Find any repetition in later part of the list</span>
            <span class="k">if</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="c1"># Current index of the first repetition</span>
                <span class="n">dim2</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span> <span class="o">+</span> <span class="n">dim1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Remove these two entries from the list</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                <span class="c1"># Append one to the end</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                <span class="c1"># Selecting diagonal entries in message</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_diagonal</span><span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">)</span>

        <span class="c1"># 3. With all predicate argument dimension converted to pattern variable dimensions and all repetitions</span>
        <span class="c1">#       diagonalized, we guarantee that all predicate variable appears in mapped_var_list.</span>
        <span class="c1">#    The last thing to do is to permute the batch dimensions so that the processed message&#39;s dimension match</span>
        <span class="c1">#       exactly with out_rel_var_list</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">])</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Outward computation. Convert pattern relational variables to predicate relational arguments. Apply mappings</span>
<span class="sd">                to relational variable&#39;s values, if specified.</span>

<span class="sd">            For outward direction, we are assuming this is used in action or condact patterns. Accordingly, the</span>
<span class="sd">                original forward mapping should be used to map pattern variables to predicate arguments.</span>

<span class="sd">            Will check anyway if domain and image of the forward map agree with the size range of the predicate argument</span>
<span class="sd">                and pattern variable respectively. However to be user friendly this should be checked beforehand by</span>
<span class="sd">                compiler.</span>

<span class="sd">            Note that image of the map should be a subset of predicate argument size range, but its domain should be</span>
<span class="sd">                exactly equal to the pattern variable size range.</span>

<span class="sd">            The computations to be carried out can be summarized in three steps: un-diagonalize, map/narrow, &amp; permute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_var_list</span><span class="p">,</span> <span class="n">out_rel_var_list</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span>

        <span class="c1"># Check that given data structures agree with variable lists of the incident variable node</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">)</span>
        <span class="c1"># Check that mapping&#39;s domain and image agree with variables&#39; sizes</span>
        <span class="c1">#   For outward computation we are using the forward map</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">var_map_tuple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pt_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">var_map_tuple</span>
            <span class="k">assert</span> <span class="n">image</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
            <span class="k">assert</span> <span class="n">domain</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">pt_var</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

        <span class="c1"># 1. First, translate pattern variables to predicate arguments. This step involves unbinding the predicate</span>
        <span class="c1">#       variables that are referenced by multiple predicate arguments.</span>
        <span class="c1">#    Computationally, this is achieved by un-diagonalize, or embed entries along that predicate variables&#39;</span>
        <span class="c1">#       dimension into a 2D plane (higher dimensional space if there are more than 2 such predicate arguments).</span>
        <span class="c1">#    A running list of variables is maintained to keep track of variable dimensions</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">mapped_var_list</span><span class="p">:</span>
            <span class="c1"># Look up how many predicate arguments reference this single pattern variable. If only 1, simply change</span>
            <span class="c1">#   variable. Otherwise, need to do more</span>
            <span class="c1"># Use .index() to get the position of current variable, instead of from enumerate() iterator, because the</span>
            <span class="c1">#   the latter does not keep up with a running list.</span>
            <span class="n">dim1</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var2arg</span><span class="p">[</span><span class="n">pt_var</span><span class="p">]</span>
            <span class="n">num_shared</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">num_shared</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="c1"># Switch pattern variable to predicate argument in-place anyway. If the pattern variable is associated with</span>
            <span class="c1">#   multiple predicate arguments, process further.</span>
            <span class="n">mapped_var_list</span><span class="p">[</span><span class="n">dim1</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num_shared</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Iterate over rest of the associated predicate arguments</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="c1"># Only arguments from the second one will be processed. First associated argument stays in-place.</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Un-diagonalize the message by embedding the entries along the i-th dimension of the original</span>
                    <span class="c1">#   message into a 2D plane specified by the i-th and the last dimension of the new message</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_diag_embed</span><span class="p">(</span><span class="n">diag_dim</span><span class="o">=</span><span class="n">dim1</span><span class="p">,</span> <span class="n">target_dim1</span><span class="o">=</span><span class="n">dim1</span><span class="p">,</span> <span class="n">target_dim2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># This corresponds to append the other dimension to the end, so we append the currently referenced</span>
                    <span class="c1">#   predicate argument Variable instance to the running variable list</span>
                    <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">)</span>

        <span class="c1"># 2. The step above guarantees a symbolic one-to-one mapping between message dimensions and predicate arguments&#39;</span>
        <span class="c1">#       variable dimensions. We now need to narrow the variable dimension if the predicate argument&#39;s size is</span>
        <span class="c1">#       smaller than the associated pattern variable&#39;s size, or to map pattern variable&#39;s value to predicate</span>
        <span class="c1">#       argument&#39;s value if a VariableMap is specified.</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">):</span>
            <span class="n">pat_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
            <span class="c1"># Apply map if VariableMap is specified</span>
            <span class="k">if</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">map_dict</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2var_map_tuple</span><span class="p">[</span><span class="n">pred_arg</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">map_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pat_var</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_index_put</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="c1"># Broaden the variable dimension size if currently it is smaller than the pattern variable&#39;s size</span>
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pred_arg</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_narrow</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">pred_arg</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># 3. Finally, with all pattern variables converted to predicate arguments and the values are now with respect to</span>
        <span class="c1">#       the predicate arguments, the last thing to do is to permute the batch dimensions so that the processed</span>
        <span class="c1">#       message&#39;s dimensions match exactly with out-_rel_var_list</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pred_arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">pred_arg</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">])</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ESFN</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expansion / Summarization Node</span>

<span class="sd">        This node is a component of the alpha conditional subgraph, so admits up to two pairs of incoming and outgoing</span>
<span class="sd">            links. Link must declare special attribute &#39;direction&#39; with value &#39;inward&#39; or &#39;outward&#39; to indicate whether</span>
<span class="sd">            it is pointing toward the conditional gamma factor node or not.</span>

<span class="sd">        For inward direction, it expands and permutes the incoming message&#39;s relational variable dimensions to match the</span>
<span class="sd">            full relational variable dimensions determined by the conditional. For outward direction, it summarizes</span>
<span class="sd">            over irrelevant relational variables and permute the dimensions to match the relational variable dimensions</span>
<span class="sd">            of this pattern.</span>

<span class="sd">        Note that the expanded dimensions will be of size 1, so that the expanded tensor is broadcastable along this</span>
<span class="sd">            dimension.</span>

<span class="sd">        The summarization step can be thought of as a search or optimization problem, where one finds a single</span>
<span class="sd">            distribution instance that best &quot;summarizes&quot; the behaviors of an entire space of distribution instances,</span>
<span class="sd">            where the dimensions of the space is defined and spanned by the irrelevant relational variables. Depending</span>
<span class="sd">            on the user-specified summarization criteria, different semantics can be interpreted for this step.</span>

<span class="sd">        A sum_op should be specified during initialization to specify special summarization semantics, such as Max</span>
<span class="sd">            Product semantics or searching. If not specified, will default to Sum-Product alike summarization. Please</span>
<span class="sd">            refer to Message class documentation for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sum_op</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Necessary data structure:</span>

<span class="sd">            :param sum_op:      None or a Summarization instance. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ESFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Expansion Summarization Factor Node&quot;</span>

        <span class="k">assert</span> <span class="n">sum_op</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_op</span><span class="p">,</span> <span class="n">Summarization</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sum_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Summarization operation using Summarization instance is not yet implemented.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sum_op</span> <span class="o">=</span> <span class="n">sum_op</span>

    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Expansion operation. Expand and permutes the incoming message&#39;s relational variable dimensions to match the</span>
<span class="sd">                outgoing relational relational variable dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_var_list</span><span class="p">,</span> <span class="n">out_rel_var_list</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span>
        <span class="c1"># Check that the set of relational variables of incoming message is a subset of that of outgoing message</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">))</span>

        <span class="c1"># Keep a running list of variables</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span>

        <span class="c1"># For every relational variable in out_rel_var_list that is not in in_rel_var_list, unsqueeze a dimension of the</span>
        <span class="c1">#   message as the last dimension.</span>
        <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pt_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_rel_var_list</span><span class="p">:</span>
                <span class="c1"># Unsqueeze message</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Append the pt_var to the end of running var list</span>
                <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">)</span>

        <span class="c1"># Permute message dimension so that it matches the order given by out_rel_var_list</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>

        <span class="c1"># Expand to full relational variable dimension shape</span>
        <span class="n">target_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">])</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_expand</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Summarization operation. Summarize over incoming message&#39;s relational variable dimensions that are not</span>
<span class="sd">                referenced by outgoing message&#39;s relational variables.</span>

<span class="sd">            The summarization semantic is defined by the sum_op specified during initialization. If sum_op is None,</span>
<span class="sd">                uses default summarization semantic defined at the Message level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>
        <span class="n">in_rel_var_list</span><span class="p">,</span> <span class="n">out_rel_var_list</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span><span class="p">,</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span>
        <span class="c1"># Check that the set of relational variables of outgoing message is a subset of that of incoming message</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">))</span>

        <span class="c1"># Keep a running list of variables</span>
        <span class="n">mapped_var_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span>

        <span class="c1"># Summarize using custom sum_op</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Flatten both the group of dimensions to be summarized over and the group of other dimensions. Put the</span>
            <span class="c1">#   former as the last dimension and the latter as the first batch dimension</span>
            <span class="n">sum_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">)</span>
            <span class="n">other_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">in_rel_var_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sum_dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># First flatten other_dims, then sum_dims, so that flattened sum_dims will be the last dim</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_flatten</span><span class="p">(</span><span class="n">other_dims</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_flatten</span><span class="p">(</span><span class="n">sum_dims</span><span class="p">)</span>
                <span class="c1"># Process using the sum_op</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_op</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="c1"># Reshape</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_reshape</span><span class="p">(</span><span class="n">other_dims</span><span class="p">)</span>

        <span class="c1"># Otherwise if sum_op is None, carry out default summarization</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Iterate over all relational variables not referenced by out_rel_var_list</span>
            <span class="k">for</span> <span class="n">pt_var</span> <span class="ow">in</span> <span class="n">in_rel_var_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pt_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">:</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>
                    <span class="c1"># Summarize over the message batch dimension</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_summarize</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="c1"># Remove the variable from the running list</span>
                    <span class="n">mapped_var_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pt_var</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_rel_var_list</span><span class="p">)</span>

        <span class="c1"># Permute message dimension so that it matches the order given by out_rel_var_list</span>
        <span class="n">perm_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapped_var_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_permute</span><span class="p">(</span><span class="n">perm_order</span><span class="p">)</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nodes relating to Conditional Beta subgraph Structures</span>
<span class="sd">        - BetaFactorNode: ESCFN, RVTFN, BJTFN</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">BetaFactorNode</span><span class="p">(</span><span class="n">FactorNode</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Abstract base class for nodes belonging to the beta subgraph of a conditional.</span>

<span class="sd">            Captures the commonality of Beta factor nodes, including link connectivity and inward &amp; outward message</span>
<span class="sd">                propagation pattern:</span>
<span class="sd">                - Groups links in terms of whether the messages moves inward to the Gamma Factor node or not.</span>
<span class="sd">                - During compute, perform inward and outward computation separately in turn by calling inward_compute()</span>
<span class="sd">                    and outward_compute()</span>

<span class="sd">            Different from Alpha nodes, there&#39;s no restriction on the number of incoming or outgoing linkdata, as long as</span>
<span class="sd">                they can be identified in terms of their messaging directionality.</span>

<span class="sd">            Need to specify &quot;direction&quot; attribute in linkdata</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Pairs of incoming and outgoing linkdata list with their messaging direction w.r.t. the beta structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;inward&#39;</span><span class="p">:</span> <span class="p">([],</span> <span class="p">[]),</span>
            <span class="s1">&#39;outward&#39;</span><span class="p">:</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linkdata</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s1">&#39;direction&#39;</span> <span class="ow">in</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span> <span class="ow">and</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;inward&#39;</span><span class="p">,</span> <span class="s1">&#39;outward&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="p">[</span><span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="p">[</span><span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="p">(</span><span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_ld_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ld_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;inward&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inward_compute</span><span class="p">(</span><span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outward_compute</span><span class="p">(</span><span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Inward message computation. To be implemented by child class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Outward message computation. To be implemented by child class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ESCFN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Event Split / Combination Node</span>

<span class="sd">        add link:</span>
<span class="sd">            - check that for inward direction, there&#39;s only one incoming link; for outward direction, only one outgoing</span>
<span class="sd">                link.</span>

<span class="sd">        Inward direction compute:</span>
<span class="sd">            1. Flatten batch dimensions into a single dimension</span>
<span class="sd">            2. If there are multiple referenced random variables, ensure that incoming message contains Particles,</span>
<span class="sd">                otherwise raise an alert.</span>
<span class="sd">            3. Translate event particles from PyTorch format to Cognitive format. If multiple pattern random variables</span>
<span class="sd">                are referenced, the events will/should be split in accordance to the size of each pattern r.v.</span>
<span class="sd">            4. If &#39;reference&#39; is True, then will cache the incoming message after each inward compute.</span>
<span class="sd">            5. If there is only one referenced pattern random variable, send translated message as is to the outgoing</span>
<span class="sd">                link. Otherwise, send split event messages to each outgoing link with corresponding pattern r.v.</span>
<span class="sd">                respectively.</span>

<span class="sd">        Outward direction compute:</span>
<span class="sd">            1. If there is inward propagation direction, check that the cache is not None. Check that incoming messages</span>
<span class="sd">                holds the same particles as the cached message. Otherwise, raise an alert.</span>
<span class="sd">            2. If there are multiple incoming links, check that messages from all incoming links have Particles. In</span>
<span class="sd">                this case, if there is cached message, combine incoming messages&#39; event particles with alignment to</span>
<span class="sd">                the cached message&#39;s event particles. Otherwise, combine incoming messages&#39; event particles randomly /</span>
<span class="sd">                without alignment.</span>
<span class="sd">            3. Reshape the single batch dimensions into full conditional batch dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ESCFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># Whether to cache referenced event particle message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linkdata</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ESCFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">linkdata</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;inward&#39;</span> <span class="ow">and</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="p">[</span><span class="s1">&#39;inward&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;outward&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">linkdata</span><span class="o">.</span><span class="n">to_fn</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labeled_ld_list_pair</span><span class="p">[</span><span class="s1">&#39;outward&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld_list</span><span class="p">,</span> <span class="n">out_ld_list</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_ld_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">in_ld</span> <span class="o">=</span> <span class="n">in_ld_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ran_var_list</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_var_list</span>
        <span class="c1"># Check that the number of outgoing links equal the number of random variables from the incoming link, and that</span>
        <span class="c1"># there&#39;s one-to-one correspondence</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_ld_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ran_var_list</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="nb">set</span><span class="p">(</span><span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">ran_var_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">out_ld</span> <span class="ow">in</span> <span class="n">out_ld_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">ran_var_list</span><span class="p">)</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>

        <span class="c1"># 1. Flatten batch dimension</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_flatten</span><span class="p">()</span>

        <span class="c1"># 2. Ensure incoming message contain particles if multiple referenced r.v.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ran_var_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Particles</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> \
                <span class="s2">&quot;In </span><span class="si">{}</span><span class="s2">: Pattern has multiple referenced random variables: </span><span class="si">{}</span><span class="s2">, however the incoming message </span><span class="si">{}</span><span class="s2"> does &quot;</span> \
                <span class="s2">&quot;not contain particles. &quot;</span>

        <span class="c1"># 3. Translate event format</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">RVTFN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">BJTFN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">RTFN</span><span class="p">(</span><span class="n">AlphaFactorNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Random Variable Transformation Node</span>

<span class="sd">        Carry out three core functionality:</span>

<span class="sd">        1. Manipulate batch dimensions:</span>
<span class="sd">            - For inward direction: flatten batch dimensions into a single dimension</span>
<span class="sd">            - for outward direction: reshape the flattened batch dimension into full batch dimensions of the conditional</span>

<span class="sd">        2. Apply transformation on events:</span>
<span class="sd">            - For inward direction: apply pre-specified transformation on event.</span>
<span class="sd">            - For outward direction: apply the INVERSE of the pre-specified transformation on events.</span>

<span class="sd">        3. Check if event values meets the pre-specified constraints.</span>
<span class="sd">            - This step will be automatically skipped if it&#39;s outward direction and/or the message does not contain</span>
<span class="sd">                event particles.</span>
<span class="sd">            - If constraints not satisfied and replaceable == False, raise an alert.</span>
<span class="sd">            - If constraints not satisfied and replaceable == True, check if the incoming message type is Both.</span>
<span class="sd">                - If yes, then reduce the message into Parameter message and send it to outgoing link.</span>
<span class="sd">                - Otherwise, raise an alert.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">replaceable</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            :param trans:       torch.distributions.transforms.Transform. The transformation functor</span>
<span class="sd">            :param constraints  a set of torch.distributions.constraints.Constraint. The value constraints of the target</span>
<span class="sd">                                    conditional&#39;s pattern random variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RTFN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretty_log</span><span class="p">[</span><span class="s2">&quot;node type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Random Variable Transformation Node&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">Transform</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replaceable</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trans</span> <span class="o">=</span> <span class="n">trans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replaceable</span> <span class="o">=</span> <span class="n">replaceable</span>

    <span class="k">def</span> <span class="nf">inward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>

        <span class="c1"># 1. Flatten batch dimensions into a single dimension</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_flatten</span><span class="p">()</span>

        <span class="c1"># 2. Apply forward transformation.</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">event_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">)</span>

        <span class="c1"># 3. Check value constraints only if message involves particles</span>
        <span class="k">if</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Particles</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
                <span class="n">valid</span> <span class="o">*=</span> <span class="n">constraint</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">particles</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

            <span class="c1"># Raise an alert if not valid and particles not replaceable.</span>
            <span class="k">assert</span> <span class="n">valid</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceable</span><span class="p">,</span> \
                <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: It has been specified that particles in incoming messages are not replaceable, but encountered &quot;</span> \
                <span class="s2">&quot;a message where the particle values do not meet pre-specified constraints: </span><span class="si">{}</span><span class="s2">&quot;</span>\
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>

            <span class="c1"># Check message type if not valid but replaceable is True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceable</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">MessageType</span><span class="o">.</span><span class="n">Parameter</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> \
                    <span class="s2">&quot;At </span><span class="si">{}</span><span class="s2">: Message must contain parameter if it&#39;s particles are to be replaced when its own particles &quot;</span> \
                    <span class="s2">&quot;do not meet the constraints. Instead, found one incoming message of type </span><span class="si">{}</span><span class="s2"> whose particles do &quot;</span> \
                    <span class="s2">&quot;not meet the constraints.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="c1"># Reduce the message into only parameters</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">reduce_type</span><span class="p">(</span><span class="n">MessageType</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">outward_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_ld</span><span class="p">,</span> <span class="n">out_ld</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_ld</span><span class="p">,</span> <span class="n">LinkData</span><span class="p">)</span>
        <span class="n">out_rel_var_list</span> <span class="o">=</span> <span class="n">out_ld</span><span class="o">.</span><span class="n">vn</span><span class="o">.</span><span class="n">rel_var_list</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">in_ld</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Message</span><span class="p">)</span>

        <span class="c1"># 1. Reshape batch dimension into full conditional relational pattern variable dimensions</span>
        <span class="n">out_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_rel_var_list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">b_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">batch_reshape</span><span class="p">(</span><span class="n">out_dims</span><span class="p">)</span>

        <span class="c1"># 2. Apply inverse transformation.</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="o">.</span><span class="n">inv</span><span class="p">)</span>

        <span class="c1"># Send message</span>
        <span class="n">out_ld</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>




<span class="k">class</span> <span class="nc">EDVN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="n">VariableNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Event Dispatch Variable Node.</span>

<span class="sd">        For inward direction:</span>
<span class="sd">            - Assume one incoming link and multiple outgoing links.</span>
<span class="sd">            - If the incoming message has particles, transform the events from PyTorch distribution event format to</span>
<span class="sd">                PySigma cognitive level event format. If there are multiple referenced pattern random variables, events</span>
<span class="sd">                will be split w.r.t. the random variable sizes, and each split message sent to the corresponding PCFN</span>
<span class="sd">                that processes the corresponding random variable.</span>
<span class="sd">            - If the incoming message does not have particles, simply send the Parameter message to all connected PCFN.</span>
<span class="sd">        For outgoing direction:</span>
<span class="sd">            - Assume one outgoing link and multiple incoming links.</span>
<span class="sd">            - If the incoming links have particles,</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">PCFN</span><span class="p">(</span><span class="n">BetaFactorNode</span><span class="p">,</span> <span class="n">FactorNode</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">GFN</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gamma Factor Node</span>

<span class="sd">        Carry out general-inference message computation at the PGM factor node.</span>

<span class="sd">        Induce a message computation task for each of the outgoing link.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>





















</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Jincheng Zhou, Yunzhe Wang, Volkan Ustun, Paul Rosenbloom @ USC Institute for Creative Technologies

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>